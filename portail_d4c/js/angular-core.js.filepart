/*
This file uses a library under MIT Licence :

ods-widgets -- https://github.com/opendatasoft/ods-widgets
Copyright (c) 2014 - Opendatasoft

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.*/
;
(function () {
    'use strict';
    var mod = angular.module('d4c.core', ['gettext', 'd4c.core.config', 'ng-sortable', 'ngSanitize']);
    mod.directive("collapsedList", function () {
        return {
            restrict: 'A',
            transclude: true,
            template: '<ul class="collapsedList"><div ng-transclude></div><li class="toggleCollapsedList"><a href="" class="more" ng-click="toggleMore()"><span class="label-more" translate>More</span><span class="label-less" translate>Less</span></a></li></ul>',
            replace: true,
            scope: {
                collapsedList: '='
            },
            controller: function ($scope, $element, $attrs) {
                this.collapseOn = $scope.collapsedList;
                $scope.toggleMore = function () {
                    jQuery('.collapsedHide', $element[0]).slideToggle();
                    jQuery('.label-more', $element[0]).toggle();
                    jQuery('.label-less', $element[0]).toggle();
                };
            },
            link: function (scope, element, attrs) {}
        };
    });
    mod.directive("collapsedItem", function () {
        return {
            restrict: 'A',
            require: ['^collapsedList'],
            link: function (scope, element, attrs, controllers) {
                var index = $.inArray(element[0], element.parent().children().get());
                if (index > controllers[0].collapseOn) {
                    element.addClass('collapsedHide');
                    element.parents('.collapsedList').find('.toggleCollapsedList').show();
                }
            }
        };
    });
    mod.directive('autofocus', ['$timeout', function ($timeout) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                if (attrs.autofocus !== "false") {
                    $timeout(function () {
                        element[0].focus();
                    }, 0);
                }
            }
        };
    }]);
    mod.directive('d4cAutofocus', ['$timeout', function ($timeout) {
        return {
            restrict: 'A',
            scope: false,
            link: function (scope, element, attrs) {
                var focusable = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]';
                if (element.is(focusable) && scope.$eval(attrs.d4cAutofocus)) {
                    $timeout(function () {
                        element[0].focus();
                    }, 0);
                }
            }
        };
    }]);
    mod.directive('delayedApplyModel', ['$parse', function ($parse) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var model = attrs.delayedApplyModel;
                var delayedApplyModelGet = $parse(model);
                var applyChange = function () {
                    scope.$apply(function () {
                        delayedApplyModelGet.assign(scope, element.val());
                    });
                };
                element.bind('keypress', function (e) {
                    var code = (e.keyCode ? e.keyCode : e.which);
                    if (code == 13) {
                        applyChange();
                    }
                });
                var valueOnFocus = element.val();
                element.bind('focus', function () {
                    valueOnFocus = element.val();
                });
                element.bind('blur', function () {
                    if (valueOnFocus !== element.val()) {
                        applyChange();
                    }
                });
                scope.$watch(model, function (newValue, oldValue) {
                    element.val(newValue);
                });
            }
        };
    }]);
    mod.directive('ngModelOnchange', function () {
        return {
            restrict: 'A',
            priority: 100,
            require: 'ngModel',
            link: function (scope, elm, attr, ngModelCtrl) {
                if (attr.type === 'radio' || attr.type === 'checkbox') return;
                elm.off('input').off('keydown').off('change');
                elm.on('change', function () {
                    scope.$apply(function () {
                        ngModelCtrl.$setViewValue(elm.val());
                    });
                });
            }
        };
    });
    mod.directive('debug', ['config', function (config) {
        return {
            restrict: 'E',
            template: '<div class="d4c-debug"><div class="d4c-debug__json-container" contenteditable="true" d4c-json-formatter="debugData" d4c-json-formatter-live-update="liveUpdate"></div></div>',
            scope: {
                data: '=',
                liveUpdate: '=?'
            },
            replace: true,
            link: function (scope) {
                scope.debugData = null;
                angular.element(document).bind('debugToggle', function () {
                    if (scope.debugData === null) {
                        scope.debugData = scope.data;
                    } else {
                        scope.debugData = null;
                    }
                    scope.$apply();
                });
            }
        };
    }]);
    $(window).on('load', function () {
        $(document.body).on('keypress', function (e) {
            if (e.charCode == 68 && e.shiftKey && !$(e.target).is('input, select, textarea') && $(e.target).attr('contenteditable') !== 'true') {
                $(document.body).toggleClass('js-show-debug');
                $(document).trigger('debugToggle');
            }
        });
    });
    mod.directive('currentItem', function () {
        return {
            restrict: 'A',
            scope: true,
            link: function (scope, element, attrs, ngModel) {
                scope.currentItem = undefined;
                scope.toggleCurrentItem = function (item) {
                    if (scope.currentItem == item) {
                        scope.currentItem = undefined;
                    } else {
                        scope.currentItem = item;
                    }
                };
            }
        };
    });
    mod.directive('dateTimePicker', function () {
        var lpad = function (val) {
            val = val.toString();
            while (val.length < 2) {
                val = '0' + val;
            }
            return val;
        };
        return {
            restrict: 'E',
            replace: true,
            scope: {
                ngModel: '=',
                format: '@',
                d4cDisabled: '='
            },
            require: 'ngModel',
            template: '<div class="date-time-picker">' + '<div ng-class="{\'date\': true, \'input-append\': !d4cDisabled}">' + '<input type="text" class="input-medium" type="text" ng-disabled="d4cDisabled" ng-model="internalModel" placeholder="{{ format }}" readonly></input>' + '<span class="add-on" ng-hide="d4cDisabled">' + '<i data-time-icon="icon-time" data-date-icon="icon-calendar"></i>' + '</span>' + '</div>' + '<span ng-if="timezone" class="timezone" translate>Local time ({{timezone}})</span>' + '</div>',
            link: function (scope, element, attrs, ngModel) {
                element.datetimepicker({
                    maskInput: true,
                    todayHighlight: true,
                    format: scope.format,
                    weekStart: 1
                });
                var isDateTime = scope.format.indexOf(' ') > -1;
                scope.timezone = null;
                if (isDateTime) {
                    var offset = new Date().getTimezoneOffset();
                    scope.timezone = ((offset < 0 ? '+' : '-') +
                        lpad(parseInt(Math.abs(offset / 60), 10)) + ':' +
                        lpad(Math.abs(offset % 60)));
                }
                scope.$watch('internalModel', function (nv, ov) {
                    if (nv) {
                        if (isDateTime) {
                            scope.ngModel = (moment(nv, "YYYY-MM-DD HH:mm:ss")).toISOString().replace('.000', '').replace('Z', "+00:00");
                        } else {
                            scope.ngModel = nv;
                        }
                    }
                });
                scope.$watch('ngModel', function (nv, ov) {
                    var date;
                    if (nv) {
                        if (isDateTime) {
                            date = moment(nv);
                            scope.internalModel = date.format('YYYY-MM-DD HH:mm:ss');
                        } else {
                            date = moment(nv);
                            scope.internalModel = date.format('YYYY-MM-DD');
                        }
                        element.datetimepicker('setValue', scope.internalModel);
                    }
                });
                var source = element.find('input');
                element.bind('changeDate', function () {
                    scope.$apply(function () {
                        scope.internalModel = source.val();
                    });
                });
            }
        };
    });
    mod.directive('slugfield', ['$filter', function ($filter) {
        return {
            require: 'ngModel',
            restrict: 'A',
            link: function (scope, element, attrs, ngModel) {
                scope.$watch(attrs.slugfield, function (nv, ov) {
                    if (nv !== ov) {
                        var slug = $filter('slugify')($filter('normalize')(nv));
                        ngModel.$viewValue = slug;
                        ngModel.$setViewValue(ngModel.$viewValue);
                        element.val(slug);
                    }
                }, true);
            }
        };
    }]);
    mod.directive('d4cForm', function () {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                model: '=',
                overrideModel: '=',
                formDefinition: '=',
                errors: '=',
                valuesLanguage: '=',
                context: '='
            },
            template: '' + '<form class="D4CForm">' + '   <d4c-form-content model="model"' + '                     override-model="overrideModel"' + '                     form-definition="formDefinition"' + '                     errors="errors"' + '                     values-language="valuesLanguage"' + '                     context="context"></d4c-form-content>' + '</form>'
        }
    });
    mod.directive('d4cFormContent', function () {
        var formUniqueId = 0;
        return {
            templateUrl: '/sites/default/files/api/portail_d4c/templates/d4c_form.html',
            replace: true,
            restrict: 'E',
            scope: {
                model: '=',
                overrideModel: '=',
                formDefinition: '=',
                errors: '=',
                valuesLanguage: '=',
                context: '='
            },
            link: function (scope, element, attrs) {
                scope.field_pattern = /^{{.*}}$/;
                if (typeof scope.model === "undefined") {
                    scope.model = {};
                }
                scope.$watch('formDefinition', function (nv, ov) {
                    if (nv) {
                        scope.has_advanced = $.grep(scope.formDefinition, function (elt) {
                            return elt.advanced;
                        }).length > 0;
                        $.each(scope.formDefinition, function (index, field) {
                            if (field.hasOwnProperty('default') && !scope.model.hasOwnProperty(field.name)) {
                                scope.model[field.name] = angular.copy(field['default']);
                            }
                            if (field.depends_on) {
                                if (!angular.isArray(field.depends_on_value)) {
                                    field.depends_on_value = [field.depends_on_value];
                                }
                            }
                        });
                    }
                });
                if (attrs.name) {
                    scope.$parent[attrs.name] = scope[attrs.name];
                }
                scope.showAdvanced = false;
                scope.toggleAdvanced = function (e) {
                    e.preventDefault();
                    scope.showAdvanced = !scope.showAdvanced;
                };
                scope.isOverridden = function (field) {
                    return scope.overrideModel && angular.isDefined(scope.overrideModel[field.name]);
                };
            },
            controller: function ($scope) {
                $scope.form_id = "form" + (++formUniqueId);
                this.isOverridable = function () {
                    return !!$scope.overrideModel;
                };
                this.isOverridden = function (field) {
                    return $scope.isOverridden(field);
                };
                this.override = function (field) {
                    if (angular.isDefined($scope.model[field.name])) {
                        $scope.overrideModel[field.name] = angular.copy($scope.model[field.name]);
                    } else {
                        var defaultValue = '';
                        if (field.type === 'list' || field.type === 'enumlist') {
                            defaultValue = [];
                        }
                        $scope.overrideModel[field.name] = defaultValue;
                    }
                };
                this.cancelOverride = function (field) {
                    delete $scope.overrideModel[field.name];
                };
            }
        };
    });
    mod.directive('d4cFormField', ['APIXHRService', '$q', function (APIXHRService, $q) {
        return {
            restrict: 'E',
            templateUrl: '/sites/default/files/api/portail_d4c/templates/d4c_form_field.html',
            replace: true,
            require: '^d4cFormContent',
            scope: {
                model: '=',
                field: '=',
                d4cDisabled: '=',
                valuesLanguage: '=',
                d4cFormId: "=",
                addentrylabel: '=?',
                context: '='
            },
            link: function (scope, element, attrs, formController) {
                if (!scope.addentrylabel) {
                    scope.addentrylabel = 'Add an entry';
                }
                var canceller = null;
                scope.d4cFormSuggestions = function (q, arg) {
                    if (canceller) {
                        canceller.resolve();
                    }
                    canceller = $q.defer();
                    return APIXHRService("GET", arg, {
                        query: q
                    }, "publish", canceller.promise).success(function () {
                        canceller = null;
                    });
                };
                scope.setValue = function (value, field) {
                    scope.model[field.name] = value.value;
                };
                scope.isOverridable = formController.isOverridable;
                scope.isOverridden = function () {
                    return formController.isOverridden(scope.field);
                };
                scope.mapValues = function (i) {
                    return i.value;
                };
                scope.override = formController.override;
                scope.cancelOverride = formController.cancelOverride;
                scope.id = scope.d4cFormId + '-' + scope.field.name;
                scope.removeObject = function (index) {
                    if (angular.isArray(scope.model[scope.field.name])) {
                        scope.model[scope.field.name].splice(index, 1);
                    }
                };
                scope.addEntry = function () {
                    if (scope.field.type === "objectlist" || scope.field.type === "unconfiguredobject") {
                        if (!scope.model[scope.field.name]) {
                            scope.model[scope.field.name] = [];
                        }
                        scope.model[scope.field.name].push({});
                    }
                };
                scope.prepareMetaForEnum = function (meta) {
                    if (angular.isString(meta)) {
                        return {
                            label: meta,
                            value: meta
                        };
                    }
                    return meta;
                };
            }
        };
    }]);
    mod.directive('oauth2', ['$compile', '$window', '$http', function ($compile, $window, $http) {
        var recompile = function (scope, element) {
            element.html($compile('<a ng-if="!authconfig[\'token\']" ng-click="openOauth2Authorization()" translate>Authorize</a>' + '<a ng-if="authconfig[\'token\']" ng-click="openOauth2Authorization()" translate>Refresh token</a>')(scope));
        };
        return {
            restrict: 'E',
            replace: 'true',
            template: '<div></div>',
            require: '^form',
            scope: {
                model: '=',
                authconfig: '=',
            },
            link: function (scope, element, attrs, formController) {
                var url, w;
                scope.$watch('authconfig', function (nv, ov) {
                    if (formController && formController.$valid) {
                        $http.post('/api/management/1.0/apis/get_oauth_authorization_url', nv).success(function (data) {
                            url = data;
                            recompile(scope, element);
                        });
                        scope.openOauth2Authorization = function () {
                            window.addEventListener('message', function (e) {
                                scope.model = e.data;
                                w.close();
                                scope.$apply();
                                recompile(scope, element);
                            });
                            w = $window.open(url);
                        };
                    }
                }, true);
            }
        };
    }]);
    mod.directive('d4cKeyValue', function () {
        return {
            restrict: 'E',
            replace: true,
            template: '<div class="key-value-input"><input ng-model="key" type="text"><span>=</span><input ng-model="value" type="text"></div>',
            scope: {
                ngModel: '='
            },
            link: function (scope, element, attrs) {
                scope.key = '';
                scope.value = '';
                scope.$watch("ngModel", function (nv) {
                    angular.forEach(nv, function (value, key) {
                        if (key !== "$$hashKey") {
                            scope.value = value;
                            scope.key = key;
                        }
                    });
                });
                scope.$watch("key", function (nv) {
                    var item = {};
                    item[nv] = scope.value;
                    angular.copy(item, scope.ngModel);
                }, true);
                scope.$watch("value", function (nv) {
                    var item = {};
                    item[scope.key] = nv;
                    angular.copy(item, scope.ngModel);
                }, true);
            }
        };
    });
    mod.directive('d4cCollapsibleFixme', function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var collapse = element.find('[d4c-collapse]');
                var panel = element.find('[d4c-collapse-panel]');
                var collapsible = false;
                var collapsed = false;
                var inList = false;
                var autoCollapse = true;
                scope.$evalAsync(function () {
                    if (panel.attr('d4c-collapse-panel')) {
                        if (scope.$eval(panel.attr('d4c-collapse-panel'))) {
                            panel.hide();
                            collapsed = true;
                        }
                    }
                    if (element.parents('.list').length > 0) {
                        inList = true;
                    }
                    if (attrs.d4cCollapsibleFixme) {
                        scope.$watch(attrs.d4cCollapsibleFixme, function (nv, ov) {
                            collapse = element.find('[d4c-collapse]');
                            panel = element.find('[d4c-collapse-panel]');
                            scope.$watch(attrs.d4cCollapsibleHead, function (nv, ov) {
                                if (nv && !collapsible) {
                                    collapse.css('cursor', 'pointer');
                                    collapse.on('click', function toggle() {
                                        panel.toggle();
                                        collapsed = !collapsed;
                                    });
                                    collapsible = true;
                                    if (inList && autoCollapse) {
                                        panel.toggle();
                                        collapsed = true;
                                    }
                                } else if (!nv && collapsible) {
                                    collapse.css('cursor', 'inherit');
                                    collapse.off('click');
                                    collapsible = false;
                                    panel.show();
                                    collapsed = false;
                                } else if (!nv && !collapsible) {
                                    autoCollapse = false;
                                }
                            });
                        }, true);
                    } else {
                        collapse.css('cursor', 'pointer');
                        collapse.on('click', function toggle() {
                            panel.toggle();
                            collapsed = !collapsed;
                        });
                    }
                });
            }
        };
    });
    mod.directive('main', function () {
        return {
            restrict: 'E',
            link: function (scope, element, attrs) {
                scope.toggleAsideLeft = function () {
                    if (scope.showAside == 'left') {
                        scope.showAside = '';
                    } else {
                        scope.showAside = 'left';
                    }
                };
                scope.toggleAsideRight = function () {
                    if (scope.showAside == 'right') {
                        scope.showAside = '';
                    } else {
                        scope.showAside = 'right';
                    }
                };
            }
        };
    });
    mod.directive('tagField', ['$compile', '$timeout', function ($compile, $timeout) {
        return {
            restrict: 'A',
            require: ['^?form'],
            scope: {
                modelitems: '=ngModel',
                tagFieldHelp: '=',
                suggestionsTag: '&',
                d4cDisabled: '='
            },
            link: function (scope, element, attrs, ctrls) {
                var formController = ctrls[0];
                if (attrs.suggestionsTag) {
                    element.html($compile('<div class="tagField" ng-class="{\'disabled\': d4cDisabled}">' + '<d4c-suggestions ng-model="newTag" d4c-disabled="d4cDisabled" source-callback="suggestionsTag({q:q})" selection-callback="addSuggestion(value)"><span ng-bind-html="item._highlightResult.value.value"></span></d4c-suggestions> ' + '<i class="icon-question-sign" d4c-tooltip="{{ tagFieldHelp }}"></i>' + '<div class="tags">' + '<div class="tag" ng-click="deleteTag($index)" ng-repeat="tag in tags">{{ tag }}</div>' + '</div>' + '</div>')(scope));
                } else {
                    element.html($compile('<div class="tagField" ng-class="{\'disabled\': d4cDisabled}">' + '<input type="text" ng-model="newTag" ng-trim="false" ng-disabled="d4cDisabled" /> ' + '<i class="icon-question-sign" d4c-tooltip="{{ tagFieldHelp }}"></i>' + '<div class="tags">' + '<div class="tag" ng-click="deleteTag($index)" ng-repeat="tag in tags">{{ tag }}</div>' + '</div>' + '</div>')(scope));
                }
                var input = element.find('input');
                scope.$watch('modelitems', function (nv) {
                    if (nv) {
                        if (angular.isString(nv)) {
                            scope.tags = [nv];
                        } else {
                            scope.tags = nv;
                        }
                    }
                }, true);
                scope.$watch('tags', function (nv) {
                    if (nv && angular.isArray(nv)) {
                        scope.modelitems = nv;
                    }
                }, true);
                scope.addSuggestion = function (value) {
                    scope.addTag(value.value);
                };
                scope.addTag = function (value) {
                    if (angular.isUndefined(scope.tags)) {
                        scope.tags = [];
                    }
                    if (scope.tags.indexOf(value) === -1) {
                        scope.tags.push(value);
                    }
                    if (formController) {
                        formController.$setDirty();
                    }
                    $timeout(function () {
                        input.focus();
                    }, 0);
                };
                scope.deleteTag = function (index) {
                    if (!scope.d4cDisabled) {
                        scope.tags.splice(index, 1);
                    }
                    if (formController) {
                        formController.$setDirty();
                    }
                };
                angular.element(input).bind('keydown', function (e) {
                    var inputValue = input.val();
                    if (e.keyCode === 13 && inputValue !== '') {
                        scope.addTag(inputValue);
                        scope.newTag = null;
                        input.val('');
                        scope.$apply();
                        input.focus();
                        return false;
                    }
                });
            }
        };
    }]);
    mod.directive('quota', ['translate', function (translate) {
        return {
            restrict: 'E',
            scope: {
                quota: "=quota",
                restrictUnit: "@",
                label: "@"
            },
            templateUrl: '/sites/default/files/api/portail_d4c/templates/quota.html',
            link: function (scope, element, attrs) {
                scope.orderUnits = ["second", "minute", "hour", "day", "month"];
                scope.units = {
                    "second": translate("second"),
                    "minute": translate("minute"),
                    "hour": translate("hour"),
                    "day": translate("day"),
                    "month": translate("month")
                };
                scope.translate = translate;
            }
        };
    }]);
    mod.directive('enumList', function () {
        return {
            restrict: 'E',
            require: 'ngModel',
            scope: {
                model: '=ngModel',
                values: '=',
                uniqueValues: '='
            },
            replace: true,
            template: '<div class="enum-list">' + '<ul ng-sortable ng-model="objectModel" class="unstyled">' + '<li ng-repeat="item in objectModel">' + '<select ng-options="key as value for (key,value) in item.values" ng-model="item.item"></select>' + '<i class="handle icon-move"></i>' + '<i class="icon-remove" ng-click="remove($index)"></i>' + '</li>' + '</ul>' + '<button type="button" class="btn" ng-click="add(\'\')" ng-disabled="addButtonDisabled"><i class="icon-plus"></i></button>' + '</div>',
            link: function (scope, element, attrs, ngModel) {
                var init = true;
                var reservedValues = [];
                scope.addButtonDisabled = false;
                scope.objectModel = [];
                if (angular.isArray(scope.values)) {
                    var values = {};
                    for (var i = 0; i < scope.values.length; i++) {
                        values[scope.values[i]] = scope.values[i];
                    }
                    scope.values = values;
                }
                var getSelectValues = function (item) {
                    var values = {};
                    var reservedValuesWithoutItem = angular.copy(reservedValues);
                    reservedValuesWithoutItem.splice(reservedValuesWithoutItem.indexOf(item), 1);
                    angular.forEach(scope.values, function (value, key) {
                        if ($.inArray(value, reservedValuesWithoutItem) === -1) {
                            values[key] = value;
                        }
                    });
                    return values;
                };
                var updateSelectValues = function () {
                    var i;
                    if (!scope.uniqueValues) return;
                    reservedValues = [];
                    for (i = 0; i < scope.objectModel.length; i++) {
                        reservedValues.push(scope.objectModel[i].item);
                    }
                    for (i = 0; i < scope.objectModel.length; i++) {
                        var item = scope.objectModel[i];
                        item.values = getSelectValues(item.item);
                        if (item.item === '') {
                            item.item = Object.keys(item.values)[0];
                        }
                    }
                    scope.addButtonDisabled = Object.keys(scope.values).length === reservedValues.length;
                };
                scope.add = function (item) {
                    scope.objectModel.push({
                        item: !scope.uniqueValues && item === '' ? Object.keys(scope.values)[0] : item,
                        values: scope.values
                    });
                    init = false;
                };
                scope.remove = function (index) {
                    scope.objectModel.splice(index, 1);
                };
                scope.$watch('model', function (nv, ov) {
                    if (nv && init) {
                        for (var i = 0; i < scope.model.length; i++) {
                            scope.add(scope.model[i]);
                        }
                        updateSelectValues();
                    }
                });
                scope.$watch('objectModel', function (nv, ov) {
                    if (nv !== ov) {
                        updateSelectValues();
                        scope.model = [];
                        for (var i = 0; i < scope.objectModel.length; i++) {
                            scope.model.push(scope.objectModel[i].item);
                        }
                    }
                }, true);
            }
        };
    });
    mod.directive('hierarchicalField', ['ModuleLazyLoader', '$compile', '$timeout', function (ModuleLazyLoader, $compile, $timeout) {
        return {
            restrict: 'E',
            require: 'ngModel',
            scope: {
                'hierarchy': '=',
                'model': '=ngModel',
                'readonly': '=ngReadonly'
            },
            replace: true,
            template: '<div class="hierarchical-field d4c-form__vertical-controls"></div>',
            link: function (scope, element) {
                ModuleLazyLoader('html-entities').then(function () {
                    scope.needFocus = -1;
                    scope.addFields = function (defaultValues) {
                        var div = $('<div class="field-group d4c-align-horizontal d4c-form__horizontal-controls"></div>');
                        for (var i = 0; i < scope.hierarchy.length; i++) {
                            var readonly = scope.readonly ? ' readonly' : '';
                            var value = defaultValues ? ' value="' + he.escape(defaultValues[i]).replace(/{[\w\s]?{/g, '') + '"' : '';
                            var input = $('<input type="text" class="d4c-form__control"' + value + readonly + ' remove-field>');
                            input.attr('placeholder', scope.hierarchy[i]);
                            if (i === 0) {
                                input.attr('list', 'autocomplete-facet');
                            }
                            input.on('change', function () {
                                if ($(this)[0] === element.find('input').last()[0]) {
                                    scope.addFields();
                                    element.find('.field-group').last().find('input').first().focus();
                                }
                                if ($(this).val() === '') {
                                    var remove = true;
                                    if ($(this)[0] === $(this).parent().find('input').last()[0] && $(this).parent()[0] !== $(this).parent().next()) {
                                        $(this).parent().next().find('input').first().change();
                                    }
                                    if (element.find('.field-group').last()[0] === $(this).parent()[0]) {
                                        if ($(this).parent().prev().find('input').last().val() !== '') {
                                            remove = false;
                                        }
                                    }
                                    angular.forEach($(this).parent().find('input'), function (input) {
                                        if ($(input).val() !== '') {
                                            remove = false;
                                        }
                                    });
                                    if (remove) {
                                        $(this).parent().remove();
                                        element.find('.field-group').last().find('input').first().focus();
                                    }
                                }
                                scope.updateModel();
                            });
                            input.on('keydown', function (event) {
                                if ($(this)[0] === $(this).parent().find('input').last()[0] && event.keyCode === 9) {
                                    scope.needFocus = scope.getElementPosition($(this)) + 1;
                                }
                                if (event.keyCode === 13) {
                                    scope.needFocus = scope.getElementPosition($(this));
                                }
                            });
                            var elem = angular.element('' + '<div class=d4c-form__group>');
                            $compile(input)(scope);
                            div.append(input);
                            if (i == scope.hierarchy.length - 1) {
                                input.keyup();
                            }
                        }
                        element.append(div);
                    };
                    scope.getElementFromPosition = function (pos) {
                        var el = element.find('.field-group input').eq(pos);
                        return el[0] ? el : element.find('.field-group').last().find('input').first();
                    };
                    scope.getElementPosition = function (el) {
                        for (var i = 0; i < element.find('.field-group input').length; i++) {
                            if (el[0] === element.find('.field-group input').eq(i)[0]) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    scope.updateModel = function () {
                        var fields = {};
                        angular.forEach(element.find('.field-group'), function (inputs) {
                            var takeInAccount = true;
                            var keys = [];
                            angular.forEach($(inputs).find('input'), function (input) {
                                var val = $(input).val();
                                keys.push(val);
                                if (val === '') {
                                    takeInAccount = false;
                                }
                            });
                            if (takeInAccount) {
                                var value = keys.splice(-1, 1);
                                var index = keys.join('.');
                                if (fields[index]) {
                                    fields[index] = fields[index].concat(value);
                                } else {
                                    fields[index] = value;
                                }
                            }
                        });
                        if (!isObjectEmpty(scope.model) || !isObjectEmpty(fields)) {
                            scope.model = fields;
                            scope.$apply();
                        }
                    };
                    scope.$watch('model', function (newValue) {
                        $timeout(function () {
                            element.find('.field-group').remove();
                            var keyValues;
                            for (var key in newValue) {
                                if (newValue[key].length == 1) {
                                    keyValues = [key].concat(newValue[key]);
                                } else {
                                    if (!angular.isArray(newValue[key])) {
                                        var item = [key].concat(newValue[key]);
                                        keyValues = item;
                                    } else {
                                        keyValues = [];
                                        angular.forEach(newValue[key], function (value) {
                                            var item = [key].concat(value);
                                            keyValues.push(item);
                                        });
                                    }
                                }
                                if (keyValues.length >= scope.hierarchy.length) {
                                    if (!angular.isArray(keyValues[0])) {
                                        scope.addFields(keyValues);
                                    } else {
                                        angular.forEach(keyValues, function (item) {
                                            scope.addFields(item);
                                        });
                                    }
                                } else {
                                    delete newValue[key];
                                }
                            }
                            scope.addFields();
                            if (scope.needFocus !== -1) {
                                scope.getElementFromPosition(scope.needFocus).focus();
                                scope.needFocus = -1;
                            }
                        }, 0);
                    }, true);
                });
            }
        };
    }]);
    mod.directive('removeField', function () {
        function addIcon(element) {
            if (element.find('i').length)
                return;
            var icon = $('<i class="icon-minus-sign"></i>');
            icon.on('click', function () {
                angular.forEach(element.find('input'), function (input) {
                    $(input).val('');
                    $(input).change();
                });
            });
            element.append(icon);
        }

        function removeIcon(element) {
            element.find('i').remove();
        }
        return {
            restrict: 'A',
            link: function (scope, element) {
                if (element.attr('readonly')) {
                    return;
                }
                element.on('keyup', function () {
                    if ($(this).val()) {
                        addIcon(element.parent());
                    } else {
                        var remove = true;
                        angular.forEach(element.parent().find('input'), function (input) {
                            if ($(input).val() !== '') {
                                remove = false;
                            }
                        });
                        if (remove) {
                            removeIcon(element.parent());
                        }
                    }
                });
            }
        };
    });
    mod.directive('datalistValues', ['translate', function (translate) {
        return {
            restrict: 'A',
            scope: {
                datalistValues: '=',
                datalistValuesLanguage: '='
            },
            link: function (scope, element, attrs) {
                var build = function (language) {
                    var dlist = angular.element('<datalist />');
                    dlist.attr('id', Math.random().toString(36).substring(7) + '-values');
                    if (element.attr('list')) {
                        $(document.body).find('datalist#' + element.attr('list')).remove();
                    }
                    element.attr('list', dlist.attr('id'));
                    for (var i = 0; i < scope.datalistValues.length; i++) {
                        var item = scope.datalistValues[i];
                        var value, label;
                        var alreadyTranslated = false;
                        if (angular.isObject(item)) {
                            if (angular.isObject(item.labels)) {
                                alreadyTranslated = true;
                                value = item.labels[language];
                                label = '';
                            } else {
                                value = item.value;
                                label = item.label;
                            }
                        } else {
                            value = item;
                            label = '';
                        }
                        if (language && !alreadyTranslated) {
                            value = translate(value, language);
                        }
                        if (angular.isDefined(value) && value !== null) {
                            dlist.append(angular.element('<option value="' + value + '">' + label + '</option>'));
                        }
                    }
                    element.after(dlist);
                };
                scope.$watch('datalistValuesLanguage', function () {
                    if (angular.isDefined(scope.datalistValues) && (!angular.isArray(scope.datalistValues) || scope.datalistValues.length > 0)) {
                        build(scope.datalistValuesLanguage);
                    }
                });
                scope.$watch('datalistValues', function (nv) {
                    if (angular.isDefined(scope.datalistValues) && (!angular.isArray(scope.datalistValues) || scope.datalistValues.length > 0)) {
                        build(scope.datalistValuesLanguage);
                    }
                });
            }
        };
    }]);
    mod.directive('datasetFieldSelector', ['translate', function (translate) {
        return {
            restrict: 'E',
            replace: true,
            template: '' + '<div class="dataset-field-selector">' + '   <select ng-disabled="d4cDisabled" ' + '           ng-model="model">' + '       <option ng-if="allowNone" value="" translate>(none)</option>' + '       <option ng-repeat="item in options" value="{{item.name}}">{{item.label}}</option>' + '   </select>' + '</div>',
            scope: {
                'model': '=ngModel',
                'fields': '=',
                'd4cDisabled': '=',
                'allowNone': '=?'
            },
            link: function (scope, element, attrs) {
                scope.allowNone = Boolean(scope.allowNone) === scope.allowNone ? scope.allowNone : true;
                scope.$watch('fields', function (fields) {
                    var options = [];
                    angular.forEach(fields, function (field) {
                        options.push({
                            name: field.name,
                            label: format_string('{label} ({type})', {
                                label: field.label,
                                type: translate(field.type)
                            })
                        })
                    });
                    scope.options = options;
                }, true);
            },
        };
    }]);
    mod.directive('multipleDatasetFieldSelector', ['$filter', function ($filter) {
        return {
            restrict: 'E',
            require: 'ngModel',
            replace: true,
            template: '<div class="multiple-dataset-field-selector">' + '<div ng-show="!d4cDisabled">' + '<ul ng-sortable ng-model="selectedFields" class="unstyled">' + '<li ng-repeat="field in selectedFields">' + '<div class="field-label" title="{{ field.label }}">{{ field.label }}</div>' + '<i class="handle icon-reorder"></i>' + '<i class="icon-remove" ng-click="remove(field)"></i>' + '</li>' + '</ul>' + '</div>' + '<ul ng-show="d4cDisabled" ng-model="selectedFields" class="unstyled">' + '<li ng-repeat="field in selectedFields">' + '<div class="field-label" title="{{ field.label }}">{{ field.label }}</div>' + '</li>' + '</ul>' + '<ul class="unstyled discarded">' + '<li ng-repeat="field in discardedFields">' + '<div class="field-label" title="{{ field.label }}">{{ field.label }}</div>' + '<i ng-if="!d4cDisabled" class="icon-plus" ng-click="add(field)"></i>' + '</li>' + '</ul>' + '</div>',
            scope: {
                'model': '=ngModel',
                'fields': '=',
                'visualization': '@',
                'd4cDisabled': '='
            },
            link: function (scope, element, attrs) {
                scope.discardedFields = [];
                scope.selectedFields = [];
                scope.$watch('fields', function (nv, ov) {
                    if (nv) {
                        scope.selectedFields = [];
                        scope.discardedFields = [];
                        if (scope.model && scope.model.length > 0) {
                            var vizFields = scope.fields;
                            if (scope.visualization) {
                                vizFields = $filter('fieldsForVisualization')(vizFields, scope.visualization);
                            }
                            angular.forEach(vizFields, function (f) {
                                var index = scope.model.indexOf(f.name);
                                if (index < 0) {
                                    scope.discardedFields.push(f);
                                } else {
                                    scope.selectedFields[index] = f;
                                }
                            });
                        } else {
                            var fields = angular.copy(scope.fields);
                            if (scope.visualization) {
                                fields = $filter('fieldsForVisualization')(fields, scope.visualization);
                            }
                            scope.selectedFields = fields;
                        }
                    }
                }, true);
                scope.$watch('selectedFields', function (nv, ov) {
                    if (nv !== ov) {
                        scope.selectedFields = scope.selectedFields.filter(function (f) {
                            return angular.isDefined(f);
                        });
                        scope.model = $.map(scope.selectedFields, function (f) {
                            return f.name;
                        });
                        var vizFields = scope.fields;
                        if (scope.visualization) {
                            vizFields = $filter('fieldsForVisualization')(vizFields, scope.visualization);
                        }
                        if (scope.model && scope.model.join('||') === $.map(vizFields, function (f) {
                                return f.name;
                            }).join('||')) {
                            scope.model = [];
                        }
                    }
                }, true);
                scope.add = function (field) {
                    scope.selectedFields.push(field);
                    scope.discardedFields.splice(scope.discardedFields.indexOf(field), 1);
                };
                scope.remove = function (field) {
                    scope.discardedFields.push(field);
                    scope.selectedFields.splice(scope.selectedFields.indexOf(field), 1);
                };
            }
        };
    }]);
    mod.directive('repeatCount', function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var count = attrs.repeatCount;
                if (count === 0) {
                    element.css('display', 'none');
                } else if (count > 1) {
                    for (var i = 1; i < count; i++) {
                        var clone = element.clone();
                        element.after(clone);
                    }
                }
            }
        };
    });
    mod.directive('scrollShadow', ['$window', function ($window) {
        return {
            scope: {
                scrollDirection: '@'
            },
            link: function (scope, element, attrs) {
                scope.scrollDirection = scope.scrollDirection || 'horizontal';

                function verticalShadows() {
                    if (element[0].scrollTop > 0) {
                        element.addClass('verticalScrollStart');
                    } else {
                        element.removeClass('verticalScrollStart');
                    }
                    if (element[0].scrollHeight > element[0].offsetHeight + element[0].scrollTop) {
                        element.addClass('verticalScrollEnd');
                    } else {
                        element.removeClass('verticalScrollEnd');
                    }
                }

                function horizontalShadows() {
                    if (element[0].scrollLeft > 0) {
                        element.addClass('horizontalScrollStart');
                    } else {
                        element.removeClass('horizontalScrollStart');
                    }
                    if (element[0].scrollWidth > element[0].offsetWidth + element[0].scrollLeft) {
                        element.addClass('horizontalScrollEnd');
                    } else {
                        element.removeClass('horizontalScrollEnd');
                    }
                }
                var shadows = scope.scrollDirection == 'vertical' ? verticalShadows : horizontalShadows;
                element.on('scroll', shadows);
                $($window).on('resize.scrollShadow', shadows);
                if (angular.isUndefined(window.MutationObserver)) {
                    scope.$watch(shadows, function () {});
                } else {
                    var observer = new MutationObserver(shadows);
                    observer.observe(element[0], {
                        childList: true,
                        subtree: true
                    });
                    scope.$on('$destroy', function () {
                        observer.disconnect();
                    });
                }
                scope.$on('$destroy', function () {
                    $($window).off('.scrollShadow');
                });
                shadows();
            }
        };
    }]);

    function initializeMap(element, MapHelper, D4CWidgetsConfig, customOptions) {
        var map = new L.D4CMap(element, customOptions);
        var defaultLoc = MapHelper.getLocationStructure(D4CWidgetsConfig.defaultMapLocation());
        map.setView(defaultLoc.center, defaultLoc.zoom);
        return map;
    }
    mod.directive('d4cPointSelector', ['D4CWidgetsConfig', 'MapHelper', 'config', function (D4CWidgetsConfig, MapHelper, config) {
        return {
            restrict: 'E',
            require: 'ngModel',
            replace: true,
            template: '<div class="map-point-selector">' + '<div class="map"></div>' + '</div>',
            link: function (scope, element, attrs, ctrl) {
                scope.scrollWheelZoom = attrs.scrollWheelZoom !== 'false';
                scope.$watch(attrs.invalidateSize, function () {
                    map.invalidateSize();
                });
                var map = initializeMap(element.find('.map')[0], MapHelper, D4CWidgetsConfig, {
                    scrollWheelZoom: scope.scrollWheelZoom,
                    basemapsList: [config.DEFAULT_BASEMAP]
                });
                var onMarkerDragged = function (e) {
                    scope.$apply(function () {
                        ctrl.$setViewValue(e.target.getLatLng());
                    });
                };
                var unwatch = scope.$watch(attrs.ngModel, function (nv, ov) {
                    if (nv) {
                        map.setView(nv, 14);
                        L.marker(nv, {
                            opacity: 0.4
                        }).addTo(map);
                        var marker = L.marker(nv, {
                            draggable: true
                        }).addTo(map);
                        marker.on('dragend', onMarkerDragged);
                    } else {
                        var controlToolbar = new L.Control.Draw({
                            draw: {
                                polyline: false,
                                polygon: false,
                                rectangle: false,
                                circle: false
                            }
                        }).addTo(map);
                        map.on('draw:created', function (e) {
                            var marker = e.layer;
                            marker.options.draggable = true;
                            map.addLayer(marker);
                            scope.$apply(function () {
                                ctrl.$setViewValue(marker.getLatLng());
                            });
                            marker.on('dragend', onMarkerDragged);
                            map.removeControl(controlToolbar);
                        });
                    }
                    unwatch();
                });
            }
        };
    }]);
    mod.directive('d4cDrawMap', ['D4CWidgetsConfig', 'MapHelper', 'config', function (D4CWidgetsConfig, MapHelper, config) {
        return {
            restrict: 'E',
            require: 'ngModel',
            replace: true,
            template: '<div class="draw-shape-map">' + '<div class="map"></div>' + '</div>',
            link: function (scope, element, attrs, ctrl) {
                scope.scrollWheelZoom = attrs.scrollWheelZoom !== 'false';
                var map = initializeMap(element.find('.map')[0], MapHelper, D4CWidgetsConfig, {
                    scrollWheelZoom: scope.scrollWheelZoom,
                    basemapsList: [config.DEFAULT_BASEMAP]
                });
                var editLayer = new L.FeatureGroup();
                map.addLayer(editLayer);
                var oldShapeLayer = new L.FeatureGroup();
                map.addLayer(oldShapeLayer);
                var drawControl = new L.Control.Draw({
                    edit: {
                        featureGroup: editLayer
                    }
                });
                map.addControl(drawControl);
                var updateModel = function () {
                    scope.$apply(function () {
                        ctrl.$setViewValue(editLayer.toGeoJSON());
                    });
                };
                map.on('draw:created', function (e) {
                    e.layer.options.opacity = 0.5;
                    editLayer.addLayer(e.layer);
                    updateModel();
                });
                map.on('draw:edited', updateModel);
                map.on('draw:deleted', updateModel);
                var bounds = null;
                scope.$watch(attrs.invalidateSize, function () {
                    map.invalidateSize();
                });
                var addGeoJsonToGroup = function (geoJson, group) {
                    L.geoJson(geoJson, {
                        onEachFeature: function (feature, layer) {
                            group.addLayer(layer);
                        }
                    });
                };
                var unwatch = scope.$watch(attrs.ngModel, function (nv, ov) {
                    if (nv) {
                        if (nv.type === "MultiPolygon") {
                            nv.coordinates.forEach(function (shapeCoords, i) {
                                addGeoJsonToGroup({
                                    type: "Polygon",
                                    coordinates: shapeCoords
                                }, oldShapeLayer);
                            });
                        } else {
                            addGeoJsonToGroup(nv, oldShapeLayer);
                        }
                        bounds = oldShapeLayer.getBounds();
                        map.fitBounds(bounds);
                    }
                    unwatch();
                });
            }
        };
    }]);
    mod.directive('d4cMarkerMap', ['D4CWidgetsConfig', 'MapHelper', 'config', function (D4CWidgetsConfig, MapHelper, config) {
        return {
            restrict: 'E',
            require: 'ngModel',
            replace: true,
            template: '<div class="map-point-selector">' + '<div class="map"></div>' + '</div>',
            link: function (scope, element, attrs, ctrl) {
                var map = initializeMap(element.find('.map')[0], MapHelper, D4CWidgetsConfig, {
                    basemapsList: [config.DEFAULT_BASEMAP]
                });
                scope.$watch(attrs.ngModel, function (nv, ov) {
                    if (isNullOrUndefined(nv)) return;
                    map.setView(nv, 14);
                    L.marker(nv).addTo(map);
                });
            }
        };
    }]);
    mod.directive('d4cGeoshapeMap', ['D4CWidgetsConfig', 'MapHelper', 'config', function (D4CWidgetsConfig, MapHelper, config) {
        return {
            restrict: 'E',
            require: 'ngModel',
            replace: true,
            template: '<div class="geoshape-map">' + '<div class="map"></div>' + '</div>',
            link: function (scope, element, attrs, ctrl) {
                var map = initializeMap(element.find('.map')[0], MapHelper, D4CWidgetsConfig, {
                    basemapsList: [config.DEFAULT_BASEMAP]
                });
                scope.$watch(attrs.ngModel, function (nv, ov) {
                    if (isNullOrUndefined(nv)) return;
                    var geoshapeLayer = L.geoJson(nv).addTo(map);
                    map.fitBounds(geoshapeLayer.getBounds());
                });
            }
        };
    }]);
    mod.directive('virtualDatasetContext', ['D4CAPI', function (D4CAPI) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var unwatch = scope.$watch(attrs.virtualDatasetContextDataset, function (nv, ov) {
                    if (nv && nv.datasetid) {
                        var contextName = attrs.virtualDatasetContext;
                        var parameters = scope.$eval(attrs.virtualDatasetContextParameters);
                        scope[contextName] = {
                            'name': contextName,
                            'type': 'dataset',
                            'apikey': null,
                            'dataset': nv,
                            'domainUrl': D4CAPI.getDomainURL(null),
                            'parameters': parameters
                        };
                        unwatch();
                    }
                });
            }
        };
    }]);
    mod.directive('virtualCatalogContext', ['D4CAPI', function (D4CAPI) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var contextName = attrs.virtualCatalogContext;
                scope[contextName] = {
                    'name': contextName,
                    'type': 'catalog',
                    'domain': null,
                    'domainUrl': D4CAPI.getDomainURL(null),
                    'apikey': null,
                    'parameters': {}
                };
            }
        };
    }]);
    mod.directive('keywordLabels', function () {
        return {
            restrict: 'E',
            replace: true,
            template: '<div class="keyword-labels"><span class="label label-info" ng-repeat="keyword in keywords" ng-click="toggleRefine(keyword)" ng-class="{\'active\': isKeywordActive(keyword), \'no-click\': noClick}">{{keyword}}</span></div>',
            scope: {
                dataset: '=',
                apiParams: '=',
                noClick: '@?'
            },
            controller: function ($scope) {
                $scope.toggleRefine = function (facetPath) {
                    var refineKey = "refine.keyword";
                    if (!$scope.apiParams[refineKey] || $scope.apiParams[refineKey] === undefined) {
                        $scope.apiParams[refineKey] = [facetPath];
                    } else {
                        var currentRefinements = $scope.apiParams[refineKey];
                        for (var i = 0; i < currentRefinements.length; i++) {
                            var refinement = currentRefinements[i];
                            if (refinement == facetPath) {
                                currentRefinements.splice(i, 1);
                                if (currentRefinements.length === 0)
                                    delete $scope.apiParams[refineKey];
                                return;
                            }
                        }
                        $scope.apiParams[refineKey].push(facetPath);
                    }
                };
                $scope.isKeywordActive = function (facetPath) {
                    if ($scope.apiParams["refine.keyword"]) {
                        var refinements = $scope.apiParams["refine.keyword"];
                        for (var i = 0; i < refinements.length; i++) {
                            var ref = refinements[i];
                            if (ref == facetPath) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                if (angular.isArray($scope.dataset.metas.keyword)) {
                    $scope.keywords = $scope.dataset.metas.keyword;
                } else {
                    $scope.keywords = [$scope.dataset.metas.keyword];
                }
            }
        };
    });
    mod.directive('datasetIcon', ['$filter', function ($filter) {
        return {
            restrict: 'AE',
            replace: true,
            template: '<li>' + '<a href="{{ url }}{{ searchOptions.headless?\'&headless=\'+searchOptions.headless:\'\' }}" target="_self" title="{{ title||\'\' | capitalize | translate }}">' + '<i class="icon-{{ icons[name] }} icon-large"></i>' + '</a>' + '</li>',
            scope: true,
            link: function (scope, element, attrs) {
                scope.icons = {
                    'metas': 'list',
                    'table': 'table',
                    'map': 'globe',
                    'calendar': 'calendar',
                    'images': 'picture',
                    'analyze': 'chart-bar',
                    'monitoring': 'chart-bar',
                    'export': 'download-alt',
                    'api': 'laptop'
                };
                scope.name = attrs.name ? attrs.name : '';
                scope.title = !attrs.title ? $filter('capitalize')(attrs.name) : attrs.title;
                scope.urlRoot = attrs.urlRoot || '';
                scope.url = !attrs.url ? scope.urlRoot + 'dataset/' + scope.dataset.datasetid + '/?tab=' + scope.name : attrs.url;
            }
        };
    }]);
    mod.directive('highlightIfCurrentLocation', function () {
        return {
            restrict: 'A',
            controller: function ($scope, $element, $attrs, $location, $document) {
                $scope.$on('$locationChangeSuccess', function (event, newUrl) {
                    if ('/' + $attrs.href === $location.path()) {
                        $element.addClass('current-location-highlight');
                    } else {
                        $element.removeClass('current-location-highlight');
                    }
                });
            }
        };
    });
    mod.directive('multiLanguageSupport', function () {
        return {
            restrict: 'EA',
            scope: true,
            link: function (scope, element, attrs) {
                scope.availableLanguages = scope.$eval(attrs.languages);
            }
        };
    });
    mod.directive('multiLanguageSelection', ['$timeout', function ($timeout) {
        return {
            restrict: 'E',
            template: '<select ng-show="visible()"></select>',
            link: function (scope, element, attrs) {
                var select = angular.element(element.children()[0]);
                scope.visible = function () {
                    return Object.keys(scope.availableLanguages).length > 1;
                };
                scope.$watch('availableLanguages', function (nv) {
                    if (nv && Object.keys(nv).length) {
                        select.empty();
                        var first;
                        angular.forEach(nv, function (label, code) {
                            first = first || code;
                            select.append(angular.element('<option value="' + code + '">' + label + '</option>'));
                        });
                        scope.selectedLanguage = null;
                        $timeout(function () {
                            scope.selectedLanguage = first;
                        }, 0);
                    }
                }, true);
                select.on('change', function () {
                    scope.$apply(function () {
                        scope.selectedLanguage = select.val();
                    });
                });
            }
        };
    }]);
    mod.directive('multiLanguageModel', ['$compile', function ($compile) {
        var convertAttributeName = function (name) {
            var i, c, converted = name[0];
            for (i = 1; i < name.length; i++) {
                c = name[i];
                if (c.toLowerCase() !== c) {
                    converted += '-' + c.toLowerCase();
                } else {
                    converted += c;
                }
            }
            return converted;
        };
        return {
            restrict: 'A',
            priority: 1,
            terminal: true,
            compile: function (tElement, tAttrs) {
                var duplicatedAttributes = {};
                angular.forEach(tAttrs, function (value, key) {
                    if (key.substring(0, 1) !== '$') {
                        if (key !== 'multiLanguageModel') {
                            duplicatedAttributes[convertAttributeName(key)] = value;
                            tAttrs.$set(key, null);
                        }
                    }
                });
                return function (scope, element, attrs) {
                    var model = scope.$eval(attrs.multiLanguageModel);
                    if (angular.isUndefined(model)) {
                        scope.$eval(attrs.multiLanguageModel + '=obj', {
                            obj: {}
                        });
                    }
                    var translatedElements = [];
                    angular.forEach(scope.availableLanguages, function (label, code) {
                        var translatedElement = element.clone();
                        translatedElement.attr(duplicatedAttributes).removeAttr('multi-language-model').removeAttr('id').attr('ng-model', attrs.multiLanguageModel + '.' + code).attr('ng-show', 'selectedLanguage == "' + code + '"');
                        element.after(translatedElement);
                        $compile(translatedElement)(scope);
                        translatedElements.push(translatedElement);
                    });
                    element.remove();
                    var blurCallback = function () {
                        var elt = angular.element(this);
                        var allEmpty = false;
                        angular.forEach(translatedElements, function (elt2) {
                            if (elt2 !== elt && elt2.val() === '') {
                                allEmpty = true;
                            }
                        });
                        if (allEmpty) {
                            angular.forEach(scope.availableLanguages, function (label, code) {
                                scope.$eval(attrs.multiLanguageModel + '.' + code + '=newVal', {
                                    newVal: elt.val()
                                });
                                scope.$apply();
                            });
                            angular.forEach(translatedElements, function (elt) {
                                elt.off('blur', blurCallback);
                            });
                        }
                    };
                    angular.forEach(translatedElements, function (elt) {
                        elt.on('blur', blurCallback);
                    });
                };
            }
        };
    }]);
    mod.directive('snapshotForm', ['ManagementAPI', function (ManagementAPI) {
        return {
            scope: {
                dataset_status: '=datasetStatus',
                dataset: '=',
            },
            templateUrl: '/sites/default/files/api/portail_d4c/templates/snapshot_form.html',
            replace: true,
            restrict: 'E',
            controller: function ($scope) {
                $scope.newSnapshot = {};
                $scope.newSnapshotCreationTime = null;
                $scope.processingSnapshots = [];
                $scope.listSnapshots = function (dataset_id) {
                    ManagementAPI.datasets.snapshots.list(dataset_id).success(function (data) {
                        $scope.snapshots = data;
                    });
                };
                $scope.isDatasetPublished = function () {
                    return $scope.dataset && $scope.dataset.published && ($scope.dataset_status.status == 'idle' || $scope.dataset_status.status == 'limit_reached');
                };
                $scope.saveSnapshot = function (dataset_id, description) {
                    ManagementAPI.datasets.snapshots.save(dataset_id, description).success(function (data) {
                        $scope.newSnapshotCreationTime = new Date();
                        $scope.listSnapshots(dataset_id);
                        $scope.savingSnapshot = true;
                        $scope.$emit('updateStatus', $scope.dataset);
                    });
                };
                $scope.deleteSnapshot = function (dataset_id, snapshot_id) {
                    $scope.processingSnapshots.push(snapshot_id);
                    ManagementAPI.datasets.snapshots['delete'](dataset_id, snapshot_id).success(function (data) {
                        var deletedSnapshotProcessingIdx = $scope.processingSnapshots.indexOf(snapshot_id);
                        var deletedSnapshotIdx = -1;
                        for (var i = 0; i < $scope.snapshots.length; i++) {
                            if ($scope.snapshots[i].snapshot_id === snapshot_id) {
                                deletedSnapshotIdx = i;
                            }
                        }
                        if (deletedSnapshotProcessingIdx !== -1) {
                            $scope.processingSnapshots.splice(deletedSnapshotProcessingIdx, 1);
                        }
                        if (deletedSnapshotIdx !== -1) {
                            $scope.snapshots.splice(deletedSnapshotIdx, 1);
                        }
                    }).error(function (data) {
                        var deletedSnapshotProcessingIdx = $scope.processingSnapshots.indexOf(snapshot_id);
                        if (deletedSnapshotProcessingIdx !== -1) {
                            $scope.processingSnapshots.splice(deletedSnapshotProcessingIdx, 1);
                        }
                    });
                };
                $scope.snapshotIsProcessing = function (snapshot_id) {
                    return $scope.processingSnapshots.indexOf(snapshot_id) !== -1;
                };
                var unwatchDataset = $scope.$watch('dataset', function (nv, ov) {
                    if (nv && nv.id) {
                        $scope.listSnapshots(nv.id);
                        unwatchDataset();
                    }
                }, true);
                $scope.$watch('dataset_status', function (nv, ov) {
                    if (nv == ov) {
                        return;
                    }
                    if ($scope.savingSnapshot && nv.status === 'idle') {
                        $scope.savingSnapshot = false;
                        $scope.newSnapshot.description = '';
                        $scope.defaultDescriptionModified = false;
                        $scope.listSnapshots($scope.dataset.id);
                    }
                });
            }
        };
    }]);
    mod.directive('d4cSplitButton', ['translate', '$compile', '$document', function (translate, $compile, $document) {
        return {
            transclude: true,
            replace: true,
            scope: true,
            restrict: 'E',
            template: '<div class="btn split-btn">' + '<div class="primary"></div>' + '<div class="drop-down" ng-click="open($event)">' + '<i class="icon-chevron-down"></i>' + '</div>' + '<div class="secondary" ng-show="opened"></div>' + '</div>',
            compile: function () {
                return {
                    pre: function (scope, element, attrs, ctrl, transclude) {
                        scope.opened = false;
                        var primary = element.find('.primary');
                        var secondary = element.find('.secondary');
                        var dropdown = element.find('.drop-down');
                        scope.open = function ($event) {
                            scope.opened = !scope.opened;
                            $document.one('click', function () {
                                scope.close();
                                scope.$apply();
                            });
                            $event.stopPropagation();
                        };
                        scope.close = function () {
                            scope.opened = false;
                        };
                        attrs.$observe("disabled", function (nv, ov) {
                            render();
                        });
                        var cloned;

                        function render() {
                            if (!cloned) return;
                            var first = true;
                            var links_attributes = [];
                            var clone = cloned.filter('a');
                            angular.forEach(clone, function (link, i) {
                                var show = true;
                                var attributes = {};
                                angular.forEach(link.attributes, function (attribute, i) {
                                    if (!show) {
                                        return;
                                    }
                                    if (attribute.name === "show-if") {
                                        show = scope.$eval(attribute.value);
                                    } else {
                                        if (!attrs.disabled || attribute.name !== "ng-click") {
                                            attributes[attribute.name] = attribute.value;
                                        }
                                    }
                                });
                                if (show) {
                                    attributes['text'] = link.innerHTML;
                                    links_attributes.push(attributes);
                                }
                            });
                            if (links_attributes.length > 0) {
                                primary.empty();
                                primary.off('click');
                                primary.html(links_attributes[0].text);
                                if (attrs.disabled) {
                                    primary.attr('ng-click', null);
                                }
                                angular.forEach(links_attributes[0], function (value, name) {
                                    if (name !== 'text') {
                                        primary.attr(name, value);
                                    }
                                });
                                primary.addClass('primary');
                                $compile(primary)(scope);
                                secondary.empty();
                                if (links_attributes.length > 1) {
                                    var el;
                                    for (var i = 0; i < links_attributes.length; i++) {
                                        el = angular.element($document[0].createElement('a'));
                                        angular.forEach(links_attributes[i], function (value, name) {
                                            if (name !== 'text') {
                                                el.attr(name, value);
                                            }
                                        });
                                        el.html(links_attributes[i].text);
                                        secondary.append(el);
                                    }
                                } else {
                                    element.find('.drop-down').remove();
                                    element.find('.secondary').remove();
                                }
                                $compile(secondary.contents())(scope.$parent);
                            }
                        }
                        transclude(scope, function (clone) {
                            cloned = clone;
                            render();
                        });
                    }
                };
            }
        };
    }]);
    mod.directive('staticfilestoreAsset', ['$http', 'd4cNotificationService', 'AssetHelper', 'ManagementAPI', function ($http, d4cNotificationService, AssetHelper, ManagementAPI) {
        var templateUrl = function (type) {
            return '/sites/default/files/api/portail_d4c/templates/assets/' + type + '.html';
        };
        return {
            restrict: 'E',
            require: '^?form',
            scope: {
                'assetName': '@',
                'type': '@',
                'config': '=',
                'response': '=',
                'buttonText': '@'
            },
            replace: true,
            template: '<div class="staticfilestore-asset {{ assetName }} {{ type }}"><div ng-include="template"></div></div>',
            link: function (scope, element, attrs, formCtrl) {
                element.on('click', '.uploadButton', function (e) {
                    $(element).find('input[type=file]')[0].click();
                });
                scope.triggerDirtyForm = function () {
                    if (angular.isDefined(formCtrl)) {
                        formCtrl.$setDirty();
                    }
                };
                scope.forceImageRefresh = function () {
                    var $img = element.find('img');
                    if ($img.length > 0) {
                        var currentImageUrl = $img.attr('src');
                        if (currentImageUrl.indexOf('?') > -1) {
                            currentImageUrl = currentImageUrl.split('?')[0];
                        }
                        $img.attr('src', currentImageUrl + '?ts=' + new Date().getTime());
                    }
                };
            },
            controller: function ($scope, $element) {
                $scope.asset = {
                    'error': null,
                    'file': null,
                    'override': false,
                    'progress': 0,
                    'success': null,
                    'url': null
                };
                $scope.template = templateUrl($scope.type);
                ManagementAPI.assets.get($scope.assetName).success(function (asset) {
                    $scope.asset.override = asset.override;
                    $scope.asset.url = asset.url;
                });
                $scope.upload = function (element) {
                    if (element.files.length === 0) {
                        return;
                    }
                    $scope.$apply(function () {
                        $scope.asset.file = element.files[0];
                        $scope.asset.progress = 0;
                        $scope.asset.success = null;
                    });
                    AssetHelper.post(ManagementAPI.assets.uploadUrl($scope.assetName), $scope.asset.file, $scope.config, {}, function (e) {
                        if (e.lengthComputable) {
                            $scope.asset.progress = Math.round(e.loaded * 100 / e.total);
                        }
                    }).then(function (data) {
                        $scope.response = data;
                        $scope.asset.override = data.override;
                        $scope.asset.url = data.url;
                        $scope.asset.error = null;
                        $scope.asset.success = true;
                        $scope.triggerDirtyForm();
                        $scope.forceImageRefresh();
                    }, function (data) {
                        $element.find('input[type=file]').val('');
                        d4cNotificationService.markNotificationAsHandled(data);
                        $scope.asset.override = data.override;
                        $scope.asset.error = data.error;
                        $scope.asset.success = false;
                    });
                };
                $scope.reset = function () {
                    ManagementAPI.assets.remove($scope.assetName).success(function (data) {
                        $element.find('input[type=file]').val('');
                        $scope.asset = {
                            'file': null,
                            'override': data.override,
                            'progress': 0,
                            'success': true,
                            'url': data.url
                        };
                        $scope.triggerDirtyForm();
                    }).error(function () {
                        $scope.asset.success = false;
                    });
                };
            }
        };
    }]);
    mod.filter('limitFrom', function () {
        return function (input, start) {
            if (!input) return;
            start = +start;
            return input.slice(start);
        };
    });
}());

function fireDOMEvent(element, eventName) {
    var evt;
    if (document.createEventObject) {
        evt = document.createEventObject();
        evt.eventType = eventName;
        evt.eventName = eventName;
        element.fireEvent('on' + evt.eventType, evt);
    } else {
        evt = document.createEvent("MouseEvents");
        evt.initEvent(eventName, true, true);
        return !element.dispatchEvent(evt);
    }
};
(function () {
    'use strict';
    var mod = angular.module('d4c.core');
    mod.filter('get_full_name', [function () {
        return function (user) {
            if (user) {
                if (user.first_name || user.last_name) {
                    return user.first_name + ' ' + user.last_name + ' (' + user.id + ')';
                } else {
                    return user.id;
                }
            }
        };
    }]);
    mod.filter('formatMeta', ['$filter', function ($filter) {
        return function (input, type) {
            if (!input) {
                return '';
            }
            var separator = ', ';
            if (angular.isArray(input)) {
                input = input.join(separator);
            }
            if (angular.isString(input)) {
                if (type === 'date') {
                    input = $filter('moment')(input, 'LL');
                } else if (type === 'datetime') {
                    input = moment.utc(input);
                    input = moment(input).local().format('LLL');
                    // input = test;
                    // input = moment($test).local().format('LLL');
                }
            } else {
                input = input.toString();
            }
            return input;
        };
    }]);
    var fixDateFormat_pattern = /(\d{2})\/(\d{2})\/(\d{4}) (\d{2}):(\d{2}):(\d{2})/;
    mod.filter('fixDateFormat', [function () {
        return function (input) {
            var match = fixDateFormat_pattern.exec(input);
            if (match) {
                input = new Date(parseInt(match[3], 10), parseInt(match[1], 10) - 1, parseInt(match[2], 10), parseInt(match[4], 10), parseInt(match[5], 10), parseInt(match[6], 10));
            }
            return input;
        };
    }]);
    var MD5 = function (string) {
        function RotateLeft(lValue, iShiftBits) {
            return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
        }

        function AddUnsigned(lX, lY) {
            var lX4, lY4, lX8, lY8, lResult;
            lX8 = (lX & 0x80000000);
            lY8 = (lY & 0x80000000);
            lX4 = (lX & 0x40000000);
            lY4 = (lY & 0x40000000);
            lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
            if (lX4 & lY4) {
                return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
            }
            if (lX4 | lY4) {
                if (lResult & 0x40000000) {
                    return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                } else {
                    return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                }
            } else {
                return (lResult ^ lX8 ^ lY8);
            }
        }

        function F(x, y, z) {
            return (x & y) | ((~x) & z);
        }

        function G(x, y, z) {
            return (x & z) | (y & (~z));
        }

        function H(x, y, z) {
            return (x ^ y ^ z);
        }

        function I(x, y, z) {
            return (y ^ (x | (~z)));
        }

        function FF(a, b, c, d, x, s, ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function GG(a, b, c, d, x, s, ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function HH(a, b, c, d, x, s, ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function II(a, b, c, d, x, s, ac) {
            a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
            return AddUnsigned(RotateLeft(a, s), b);
        }

        function ConvertToWordArray(string) {
            var lWordCount;
            var lMessageLength = string.length;
            var lNumberOfWords_temp1 = lMessageLength + 8;
            var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
            var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
            var lWordArray = Array(lNumberOfWords - 1);
            var lBytePosition = 0;
            var lByteCount = 0;
            while (lByteCount < lMessageLength) {
                lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                lBytePosition = (lByteCount % 4) * 8;
                lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
                lByteCount++;
            }
            lWordCount = (lByteCount - (lByteCount % 4)) / 4;
            lBytePosition = (lByteCount % 4) * 8;
            lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
            lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
            lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
            return lWordArray;
        }

        function WordToHex(lValue) {
            var WordToHexValue = "",
                WordToHexValue_temp = "",
                lByte, lCount;
            for (lCount = 0; lCount <= 3; lCount++) {
                lByte = (lValue >>> (lCount * 8)) & 255;
                WordToHexValue_temp = "0" + lByte.toString(16);
                WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
            }
            return WordToHexValue;
        }

        function Utf8Encode(string) {
            string = string.replace(/\r\n/g, "\n");
            var utftext = "";
            for (var n = 0; n < string.length; n++) {
                var c = string.charCodeAt(n);
                if (c < 128) {
                    utftext += String.fromCharCode(c);
                } else if ((c > 127) && (c < 2048)) {
                    utftext += String.fromCharCode((c >> 6) | 192);
                    utftext += String.fromCharCode((c & 63) | 128);
                } else {
                    utftext += String.fromCharCode((c >> 12) | 224);
                    utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                    utftext += String.fromCharCode((c & 63) | 128);
                }
            }
            return utftext;
        }
        var x = Array();
        var k, AA, BB, CC, DD, a, b, c, d;
        var S11 = 7,
            S12 = 12,
            S13 = 17,
            S14 = 22;
        var S21 = 5,
            S22 = 9,
            S23 = 14,
            S24 = 20;
        var S31 = 4,
            S32 = 11,
            S33 = 16,
            S34 = 23;
        var S41 = 6,
            S42 = 10,
            S43 = 15,
            S44 = 21;
        string = Utf8Encode(string);
        x = ConvertToWordArray(string);
        a = 0x67452301;
        b = 0xEFCDAB89;
        c = 0x98BADCFE;
        d = 0x10325476;
        for (k = 0; k < x.length; k += 16) {
            AA = a;
            BB = b;
            CC = c;
            DD = d;
            a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
            d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
            c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
            b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
            a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
            d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
            c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
            b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
            a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
            d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
            c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
            b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
            a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
            d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
            c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
            b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
            a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
            d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
            c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
            b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
            a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
            d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
            c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
            b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
            a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
            d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
            c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
            b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
            a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
            d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
            c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
            b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
            a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
            d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
            c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
            b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
            a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
            d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
            c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
            b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
            a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
            d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
            c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
            b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
            a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
            d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
            c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
            b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
            a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);
            d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
            c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
            b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
            a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
            d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
            c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
            b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
            a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
            d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
            c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);
            b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
            a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
            d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
            c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
            b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
            a = AddUnsigned(a, AA);
            b = AddUnsigned(b, BB);
            c = AddUnsigned(c, CC);
            d = AddUnsigned(d, DD);
        }
        var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);
        return temp.toLowerCase();
    };
    mod.filter('gravatar', [function () {
        return function (email, size) {
            if (!size) {
                size = 80;
            }
            if (email) {
                return "//www.gravatar.com/avatar/" + MD5(email.toLowerCase()) + "?d=mm&s=" + size;
            } else {
                return "//www.gravatar.com/avatar/00000000000000000000000000000000?d=mm&f=y&s=" + size;
            }
        };
    }]);
    mod.filter('suggestTypeToIcon', function () {
        return function (type) {
            switch (type) {
                case 'dataset':
                    return 'archive';
                default:
                    return type;
            }
        };
    });
    mod.filter('eventClass', function () {
        return function (event) {
            switch (event) {
                case 'add_dataset':
                    return 'add';
                case 'edit_dataset':
                case 'publish_dataset':
                case 'unpublish_dataset':
                    return 'edit';
                case 'delete_dataset':
                    return 'delete';
                default:
                    return event;
            }
        };
    });
    mod.filter('event', ['translate', function (translate) {
        return function (event) {
            switch (event) {
                case '':
                    return translate('Any');
                case 'add_dataset':
                    return translate('Add');
                case 'edit_dataset':
                    return translate('Edit');
                case 'delete_dataset':
                    return translate('Delete');
                case 'publish_dataset':
                    return translate('Publish');
                case 'unpublish_dataset':
                    return translate('Unpublish');
                default:
                    return event;
            }
        };
    }]);
    mod.filter('toArray', function () {
        return function (dict) {
            if (dict) {
                return $.map(dict, function (v, k) {
                    return v;
                });
            } else {
                return [];
            }
        };
    });
    mod.filter('filterObject', function () {
        return function (dict, key) {
            var filtered = angular.copy(dict);
            if (!angular.isArray(key)) {
                key = [key];
            }
            for (var i = 0; i < key.length; i++) {
                delete(filtered[key[i]]);
            }
            return filtered;
        };
    });
    mod.filter('listFilter', [function () {
        return function (inputList, filterList) {
            if (!inputList) {
                return '';
            }
            if (!filterList) {
                return inputList;
            }
            Array.prototype.diff = function (a) {
                return this.filter(function (i) {
                    return (a.indexOf(i) < 0);
                });
            };
            return inputList.filter(function (i) {
                return (filterList.indexOf(i) < 0);
            });
        };
    }]);
    mod.filter('licenseLink', function () {
        var licenses = [{
            pattern: /odbl.*fr/gi,
            url: 'http://vvlibri.org/fr/licence/odbl-10/legalcode/unofficial'
        }, {
            pattern: /odbl/gi,
            url: 'http://opendatacommons.org/licenses/odbl/'
        }, {
            pattern: /open database license/gi,
            url: 'http://opendatacommons.org/licenses/odbl/'
        }, {
            pattern: /licence ouverte v2/gi,
            url: 'https://www.etalab.gouv.fr/wp-content/uploads/2017/04/ETALAB-Licence-Ouverte-v2.0.pdf'
        }, {
            pattern: /licence ouverte/gi,
            url: 'https://www.etalab.gouv.fr/wp-content/uploads/2014/05/Licence_Ouverte.pdf'
        }, {
            pattern: /etalab/gi,
            url: 'https://www.etalab.gouv.fr/wp-content/uploads/2014/05/Licence_Ouverte.pdf'
        }, {
            pattern: /creative commons[\w-]by[\w-]sa/gi,
            url: 'http://opendefinition.org/licenses/cc-by-sa/'
        }, {
            pattern: /creative commons.*share.*alike/gi,
            url: 'http://opendefinition.org/licenses/cc-by-sa/'
        }, {
            pattern: /creative commons/gi,
            url: 'http://www.opendefinition.org/licenses/cc-by/'
        }, {
            pattern: /cc[\w\s-]by$/gi,
            url: 'https://creativecommons.org/licenses/by/4.0/'
        }, {
            pattern: /cc[\w\s-]by[\w\s-]nd/gi,
            url: 'https://creativecommons.org/licenses/by-nd/4.0/'
        }, {
            pattern: /cc[\w\s-]by[\w\s-]nc[\w\s-]nd/gi,
            url: 'https://creativecommons.org/licenses/by-nc-nd/4.0/'
        }, {
            pattern: /cc[\w\s-]by[\w\s-]nc$/gi,
            url: 'https://creativecommons.org/licenses/by-nc/4.0/'
        }, {
            pattern: /cc[\w\s-]by[\w\s-]nc[\w\s-]sa/gi,
            url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/'
        }, {
            pattern: /cc[\w\s-]by[\w\s-]sa/gi,
            url: 'https://creativecommons.org/licenses/by-sa/4.0/'
        }, {
            pattern: /cc[\w\s-]by[\w\s-]igo/gi,
            url: 'https://creativecommons.org/licenses/by/3.0/igo/'
        }, {
            pattern: /cc[\w\s-]?0/gi,
            url: 'https://creativecommons.org/publicdomain/zero/1.0/'
        }, {
            pattern: /Datenlizenz Deutschland.*Zero.*Version 2/gi,
            url: 'https://www.govdata.de/dl-de/zero-2-0'
        }, {
            pattern: /Datenlizenz Deutschland.*Namensnennung.*Version 2/gi,
            url: 'https://www.govdata.de/dl-de/by-2-0'
        }, {
            pattern: /(odbl|open data) paris/gi,
            url: 'http://opendata.paris.fr/page/lalicence/'
        }, {
            pattern: /SNCF Open Data/gi,
            url: 'https://data.sncf.com/pages/cgu/A1#A1'
        }, {
            pattern: /Datainfogreffe/gi,
            url: 'https://www.datainfogreffe.fr/page/licence/'
        }, {
            pattern: /Licence .* des Archives de la Plan.+te/gi,
            url: 'https://opendata.hauts-de-seine.fr/page/licence-adlp/'
        }, {
            pattern: /cc[\w\s-]by[\w\s-]nc[\w\s-]nd 3.*fr/gi,
            url: 'http://creativecommons.org/licenses/by-nc-nd/3.0/fr/legalcode'
        }, {
            pattern: /open government licence/gi,
            url: 'http://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/'
        }, {
            pattern: /API STIF/gi,
            url: 'https://opendata.stif.info/page/licence-api-stif/'
        }];
        return function (licenseString) {
            if (!licenseString || licenseString === '') {
                return licenseString;
            }
            for (var i = 0; i < licenses.length; i++) {
                var license = licenses[i];
                if (licenseString.search(license.pattern) > -1) {
                    return '<a rel="nofollow" target="_blank" href="' + license.url + '">' + licenseString + '</a>';
                }
            }
            return licenseString;
        };
    });
    mod.filter('vizConfig', function () {
        return function (dataset, fieldConfigName) {
            if (dataset.extra_metas && dataset.extra_metas.visualization && dataset.extra_metas.visualization[fieldConfigName]) {
                return dataset.extra_metas.visualization[fieldConfigName];
            }
            return null;
        };
    });
    mod.filter('hasFacet', function () {
        return function (dataset) {
            if (dataset) {
                dataset = new D4C.Dataset(dataset);
                return dataset.hasFacet();
            }
            return false;
        };
    });
    mod.filter('hasFieldType', function () {
        return function (dataset, fieldType) {
            if (angular.isObject(dataset)) {
                dataset = new D4C.Dataset(dataset);
                return dataset.hasFieldType(fieldType);
            }
            return false;
        };
    });
    mod.filter('countFieldType', function () {
        return function (dataset, fieldType) {
            if (dataset) {
                dataset = new D4C.Dataset(dataset);
                return dataset.countFieldType(fieldType);
            }
            return 0;
        };
    });
    mod.filter('countFieldTypes', function () {
        return function (dataset, fieldType) {
            if (dataset) {
                dataset = new D4C.Dataset(dataset);
                return dataset.countFieldTypes(fieldType);
            }
            return 0;
        };
    });
    $.objectDiff = function (a, b, c) {
        c = {};
        try {
            $.each([a, b], function (index, obj) {
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        if (typeof obj[prop] === "object" && obj[prop] !== null) {
                            c[prop] = $.objectDiff(a[prop], b[prop], c);
                        } else {
                            if (a === undefined) a = {};
                            if (b === undefined) b = {};
                            if (a[prop] !== b[prop]) {
                                c[prop] = [a[prop], b[prop]];
                            }
                        }
                    }
                }
            });
        } catch (e) {
            console.error(e);
        }
        return c;
    };
    mod.filter('diff', function () {
        return function (a, b) {
            return $.objectDiff(a, b);
        };
    });
    mod.filter('range', function () {
        return function (input) {
            var lowBound, highBound;
            switch (input.length) {
                case 1:
                    lowBound = 0;
                    highBound = parseInt(input[0], 10) - 1;
                    break;
                case 2:
                    lowBound = parseInt(input[0], 10);
                    highBound = parseInt(input[1], 10);
                    break;
                default:
                    return input;
            }
            var result = [];
            for (var i = lowBound; i <= highBound; i++)
                result.push(i);
            return result;
        };
    });
    mod.filter('startsWith', function () {
        return function (input, searchedString) {
            return D4C.StringUtils.startsWith(input, searchedString);
        };
    });
    mod.filter('displayedRefines', ['translate', function (translate) {
        return function (searchOptions) {
            var displayedRefines = {};
            $.each(searchOptions, function (key, value) {
                if (key == 'q') {
                    displayedRefines[translate('query')] = value;
                }
                if (key.slice(0, 7) == 'refine.') {
                    if (angular.isArray(value)) {
                        displayedRefines[key.slice(7)] = value.join(', ');
                    } else {
                        displayedRefines[key.slice(7)] = value;
                    }
                }
            });
            return displayedRefines;
        };
    }]);
    mod.filter('currentLanguage', ['config', function (config) {
        return function (language) {
            return language.toLowerCase() == config.LANGUAGE;
        };
    }]);
    mod.filter('siPrefixFormat', ['$filter', function ($filter) {
        return function (number) {
            if (number >= 1000000) {
                return $filter('number')(number / 1000000, 0) + 'M';
            } else if (number >= 10000) {
                return $filter('number')(number / 1000, 0) + 'k';
            } else if (number >= 1000) {
                return $filter('number')(number / 1000, 1) + 'k';
            } else {
                return $filter('number')(number, 0);
            }
        };
    }]);
    mod.filter('min', function () {
        return function (n1, n2) {
            return Math.min(n1, n2);
        };
    });
    mod.filter('max', function () {
        return function (n1, n2) {
            return Math.max(n1, n2);
        };
    });
    mod.filter('isPositiveNumber', function () {
        return function (input) {
            if (angular.isNumber(input) && isFinite(input) && input >= 0) {
                return true;
            } else {
                return false;
            }
        };
    });
    mod.filter('incrementBound', function () {
        return function (firstBound) {
            if (angular.isDefined(firstBound) && firstBound !== "") {
                return D4C.CalculationUtils.incrementByOneUnit(firstBound);
            } else {
                return null;
            }
        };
    });
    mod.filter('encodeURIComponent', ['$window', function ($window) {
        return $window.encodeURIComponent;
    }]);
}());;
(function () {
    'use strict';
    var betterTab = function (cm) {
        if (cm.somethingSelected()) {
            cm.indentSelection("add");
        } else {
            cm.replaceSelection(cm.getOption("indentWithTabs") ? "\t" : Array(cm.getOption("indentUnit") + 1).join(" "), "end", "+input");
        }
    };
    var app = angular.module('d4c.core');
    app.factory("codeMirrorOptions", [function () {
        return {
            css: {
                mode: 'text/css',
                lineNumbers: true,
                indentWithTabs: false,
                indentUnit: 4,
                styleActiveLine: true,
                viewportMargin: Infinity,
                foldGutter: true,
                gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
                matchBrackets: true,
                autoCloseBrackets: true,
                extraKeys: {
                    Tab: betterTab,
                    "Ctrl-Space": "autocomplete"
                }
            },
            html: {
                mode: 'text/html',
                lineNumbers: true,
                indentWithTabs: false,
                indentUnit: 4,
                styleActiveLine: true,
                viewportMargin: Infinity,
                foldGutter: true,
                gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
                matchTags: {
                    bothTags: true
                },
                autoCloseTags: true,
                extraKeys: {
                    Tab: betterTab,
                    "Ctrl-Space": "autocomplete"
                }
            }
        };
    }]);
})();;
(function () {
    'use strict';
    var mod = angular.module('d4c.core');
    mod.service('ColorHelper', ['translate', function (translate_color) {
        var PI2 = Math.PI * 2,
            PIp180 = Math.PI / 180,
            validHexColor = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
        return {
            HexToRGB: function (hex) {
                if (hex.startsWith("#")) {
                    hex = hex.substring(1);
                }
                return [parseInt(hex.substring(0, 2), 16), parseInt(hex.substring(2, 4), 16), parseInt(hex.substring(4, 6), 16)];
            },
            RGBToHex: function (r, g, b) {
                return ("#" + ((1 << 24) +
                    (Math.round(r) << 16) +
                    (Math.round(g) << 8) +
                    Math.round(b)).toString(16).slice(1)).toUpperCase();
            },
            RGBToHSV: function (r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                var max = Math.max(r, g, b),
                    min = Math.min(r, g, b);
                var h, s, v = max;
                var d = max - min;
                s = max === 0 ? 0 : d / max;
                if (max == min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return [h, s, v];
            },
            HSVToRGB: function (h, s, v) {
                h *= 6;
                var i = ~~h,
                    f = h - i,
                    p = v * (1 - s),
                    q = v * (1 - f * s),
                    t = v * (1 - (1 - f) * s),
                    mod = i % 6,
                    r = [v, q, p, p, t, v][mod] * 255,
                    g = [t, v, v, q, p, p][mod] * 255,
                    b = [p, p, t, v, v, q][mod] * 255;
                r = ~~r;
                g = ~~g;
                b = ~~b;
                return [r, g, b, "rgb(" + r + "," + g + "," + b + ")"];
            },
            RGBToXYV: function (red, green, blue, radius) {
                var hsv = this.RGBToHSV(red, green, blue),
                    width = radius * 2,
                    phi, r, x, y;
                hsv[0] = hsv[0] * 360;
                r = radius * hsv[1];
                phi = hsv[0] * PIp180;
                x = radius + r * Math.cos(phi);
                y = radius + r * Math.sin(phi);
                return [Math.round(width - x), Math.round(width - y), hsv[2]];
            },
            XYToHS: function (x, y, radius) {
                x = x - radius;
                y = y - radius;
                var theta = Math.atan2(y, x),
                    d = x * x + y * y;
                if (d > radius * radius) {
                    x = radius * Math.cos(theta);
                    y = radius * Math.sin(theta);
                    theta = Math.atan2(y, x);
                    d = x * x + y * y;
                }
                return [(theta + Math.PI) / PI2, Math.sqrt(d) / radius];
            },
            isValidHexColor: function (hex) {
                if (!hex) {
                    return false;
                }
                hex = hex.trim();
                return validHexColor.test(hex);
            },
            formatHexColor: function (hex) {
                if (!hex) {
                    return;
                }
                hex = hex.trim();
                if (!hex.startsWith("#")) {
                    hex = "#" + hex;
                }
                if (!this.isValidHexColor(hex)) {
                    return;
                }
                return hex.toUpperCase();
            },
            shortToLongHexColor: function (hex) {
                hex = hex.trim();
                if (!hex.startsWith("#")) {
                    hex = "#" + hex;
                }
                if (hex.length == 7) {
                    return hex;
                } else if (hex.length < 4) {
                    return null;
                }
                return hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
            },
            isDarkColor: function (red, green, blue) {
                var brightness;
                brightness = (red * 299) + (green * 587) + (blue * 114);
                brightness = brightness / 255000;
                if (brightness >= 0.5) {
                    return false;
                } else {
                    return true;
                }
            },
            loadWheel: function (radius, pixels, value) {
                var i = 0,
                    radiusSquared = radius * radius,
                    diameter = radius * 2;
                for (var y = 0; y < diameter; y++) {
                    for (var x = 0; x < diameter; x++) {
                        var rx = x - radius,
                            ry = y - radius,
                            d = rx * rx + ry * ry,
                            rgb = this.HSVToRGB((Math.atan2(ry, rx) + Math.PI) / PI2, Math.sqrt(d) / radius, value / 100);
                        pixels[i++] = rgb[0];
                        pixels[i++] = rgb[1];
                        pixels[i++] = rgb[2];
                        pixels[i++] = d > radiusSquared ? 0 : 255;
                    }
                }
            },
            niceColors: [
                [
                    [translate_color('Black'), '#000000', ''],
                    [translate_color('Dark grey'), '#555555', ''],
                    [translate_color('Light grey'), '#AAAAAA', ''],
                    [translate_color('White'), '#FFFFFF', 'lightgrey'],
                ],
                [
                    [translate_color('Dark slate'), '#2C3F56', ''],
                    [translate_color('Medium slate'), '#6D7A87', ''],
                    [translate_color('Light slate'), '#969FAA', ''],
                    [translate_color('Pale slate'), '#C0C5CC', '']
                ],
                [
                    [translate_color('Dark green'), '#19630A', ''],
                    [translate_color('Medium green'), '#64905C', ''],
                    [translate_color('Light green'), '#8FAF89', ''],
                    [translate_color('Pale green'), '#BCD0B8', ''],
                ],
                [
                    [translate_color('Dark oil'), '#00757E', ''],
                    [translate_color('Medium oil'), '#5D9FA3', ''],
                    [translate_color('Light oil'), '#8ABABE', ''],
                    [translate_color('Pale oil'), '#B8D5D8', ''],
                ],
                [
                    [translate_color('Dark blue'), '#0B72B5', ''],
                    [translate_color('Medium blue'), '#619FC8', ''],
                    [translate_color('Light blue'), '#8EBAD8', ''],
                    [translate_color('Pale blue'), '#BBD5E7', ''],
                ],
                [
                    [translate_color('Dark royal blue'), '#263892', ''],
                    [translate_color('Medium royal blue'), '#6A79B0', ''],
                    [translate_color('Light royal blue'), '#939EC6', ''],
                    [translate_color('Pale royal blue'), '#BEC5DC', ''],
                ],
                [
                    [translate_color('Dark purple'), '#5A1887', ''],
                    [translate_color('Medium purple'), '#8A65A9', ''],
                    [translate_color('Light purple'), '#AB90C1', ''],
                    [translate_color('Pale purple'), '#CDBCD9', ''],
                ],
                [
                    [translate_color('Dark fuchsia'), '#93117E', ''],
                    [translate_color('Medium fuchsia'), '#B060A3', ''],
                    [translate_color('Light fuchsia'), '#C78DBD', ''],
                    [translate_color('Pale fuchsia'), '#DDBBD7', ''],
                ],
                [
                    [translate_color('Dark cherry'), '#BA022A', ''],
                    [translate_color('Medium cherry'), '#CB516D', ''],
                    [translate_color('Light cherry'), '#D98396', ''],
                    [translate_color('Pale cherry'), '#E8B4C0', ''],
                ],
                [
                    [translate_color('Dark vermilion'), '#E5352D', ''],
                    [translate_color('Medium vermilion'), '#E87273', ''],
                    [translate_color('Light vermilion'), '#EE9A9A', ''],
                    [translate_color('Pale vermilion'), '#F5C2C2', ''],
                ],
                [
                    [translate_color('Dark orange'), '#FA8C44', ''],
                    [translate_color('Medium orange'), '#F7AD84', ''],
                    [translate_color('Light orange'), '#F9C4A7', ''],
                    [translate_color('Pale orange'), '#FCDCCA', ''],
                ],
                [
                    [translate_color('Dark yellow'), '#F8B334', ''],
                    [translate_color('Medium yellow'), '#F7C87E', ''],
                    [translate_color('Light yellow'), '#F9D7A2', ''],
                    [translate_color('Pale yellow'), '#FBE6C6', ''],
                ],
            ],
        };
    }]);
})();;
(function () {
    'use strict';
    var mod = angular.module('d4c.core');
    mod.service('FlashService', function () {
        var counter = 0;
        return {
            flashes: [],
            send: function (flash) {
                var self = this;
                if (angular.isString(flash)) {
                    flash = {
                        type: 'info',
                        content: flash,
                        isDismissible: true,
                        onDismiss: null,
                    };
                }
                if (!flash.type) {
                    flash.type = 'info';
                }
                if (!angular.isDefined(flash.isDismissible)) {
                    flash.isDismissible = true;
                }
                flash.id = counter++;
                flash.dismiss = function () {
                    self.dismiss(flash);
                };
                this.flashes.push(flash);
                return flash;
            },
            dismiss: function (flash) {
                if (!flash.isDismissible) {
                    return;
                }
                var i = this.flashes.length;
                while (i--) {
                    if (this.flashes[i].id === flash.id) {
                        this.flashes.splice(i, 1);
                    }
                }
                if (angular.isFunction(flash.onDismiss)) {
                    flash.onDismiss();
                }
            },
            sendSuccess: function (flash) {
                if (angular.isString(flash)) {
                    flash = {
                        type: 'success',
                        content: flash
                    };
                } else {
                    flash.type = 'success';
                }
                return this.send(flash);
            },
            sendInfo: function (flash) {
                if (angular.isString(flash)) {
                    flash = {
                        type: 'info',
                        content: flash
                    };
                } else {
                    flash.type = 'info';
                }
                return this.send(flash);
            },
            sendWarning: function (flash) {
                if (angular.isString(flash)) {
                    flash = {
                        type: 'warning',
                        content: flash
                    };
                } else {
                    flash.type = 'warning';
                }
                return this.send(flash);
            },
            sendDanger: function (flash) {
                if (angular.isString(flash)) {
                    flash = {
                        type: 'danger',
                        content: flash
                    };
                } else {
                    flash.type = 'danger';
                }
                return this.send(flash);
            }
        };
    });
})();;
(function () {
    "use strict";
    var mod = angular.module('d4c.core');
    mod.factory('d4cBindModelToScope', function () {
        return function (scope, ngModelCtrl) {
            ngModelCtrl.$render = function () {
                scope.model = angular.copy(ngModelCtrl.$viewValue);
            };
            scope.$watch('model', function () {
                ngModelCtrl.$setViewValue(scope.model);
            }, true);
        };
    });
    mod.factory('d4cFormInputHelper', ['$parse', function ($parse) {
        var isStateFunction = function (state) {
            var ngState = 'ng' + state.charAt(0).toUpperCase() + state.slice(1);
            return function (scope, attrs) {
                return !!(ngState in attrs && $parse(attrs[ngState])(scope.$parent));
            };
        };
        var isReadonly = isStateFunction('readonly');
        var isDisabled = isStateFunction('disabled');
        return {
            isReadonly: isReadonly,
            isDisabled: isDisabled
        };
    }]);
    mod.factory('d4cBindInputStateToScope', ['d4cFormInputHelper', function (d4cFormInputHelper) {
        return function (scope, attrs) {
            scope.$watch(function () {
                return [d4cFormInputHelper.isDisabled(scope, attrs), d4cFormInputHelper.isReadonly(scope, attrs)];
            }, function (nv) {
                scope.disabled = nv[0];
                scope.readonly = nv[1];
            }, true);
        };
    }]);
    mod.factory('d4cCompileAndReplace', ['$compile', function ($compile) {
        return function (scope, element, template) {
            var newElement = angular.element(template);
            element.replaceWith(newElement);
            $compile(newElement)(scope);
            return newElement;
        };
    }]);
    mod.factory('d4cCustomInputHelper', function () {
        return {
            getAndResetNgModelOptions: function (ngModelOptionsCtrl) {
                var ngModelOptions = {};
                if (ngModelOptionsCtrl && ngModelOptionsCtrl.$options) {
                    ngModelOptions = angular.copy(ngModelOptionsCtrl.$options);
                    for (var key in ngModelOptionsCtrl.$options) {
                        if (ngModelOptionsCtrl.$options.hasOwnProperty(key)) {
                            delete ngModelOptionsCtrl.$options[key];
                        }
                    }
                    ngModelOptionsCtrl.$options.updateOnDefault = true;
                }
                if (ngModelOptions.updateOnDefault) {
                    if (ngModelOptions.updateOn) {
                        ngModelOptions.updateOn += ' default';
                    } else {
                        ngModelOptions.updateOn = 'default';
                    }
                }
                if (!ngModelOptions.debounce) {
                    ngModelOptions.debounce = {};
                }
                return ngModelOptions;
            },
            setMainControlDirty: function (formCtrl, name) {
                if (formCtrl && name && formCtrl[name]) {
                    formCtrl[name].$setDirty();
                }
            }
        };
    });
    mod.factory('d4cCustomInput', ['d4cBindInputStateToScope', 'd4cCompileAndReplace', function (d4cBindInputStateToScope, d4cCompileAndReplace) {
        return function (scope, element, attrs, template) {
            d4cBindInputStateToScope(scope, attrs);
            return d4cCompileAndReplace(scope, element, template);
        };
    }]);
    mod.factory('d4cMultiInputHelper', ['$timeout', 'd4cCustomInputHelper', '$rootScope', function ($timeout, d4cCustomInputHelper, $rootScope) {
        return {
            setupNewValue: function (scope, element, formCtrl, insertAtEnd) {
                scope.addNewValue = function () {
                    if (!scope.newValue) {
                        return;
                    }
                    if (scope.values.indexOf(scope.newValue) === -1) {
                        if (insertAtEnd) {
                            scope.values.push(scope.newValue);
                        } else {
                            scope.values.unshift(scope.newValue);
                        }
                        scope.newValue = '';
                    } else {
                        formCtrl[scope.name + '-new'].$setValidity('unique', false);
                    }
                    $timeout(function () {
                        element.find('.d4c-form__control')[0].focus();
                    });
                };
                var validate = function () {
                    if (!scope.newValue || scope.values.indexOf(scope.newValue) === -1) {
                        formCtrl[scope.name + '-new'].$setValidity('unique', true);
                    }
                };
                scope.$watch('newValue', validate);
                scope.$watch('values', validate, true);
                scope.onNewValueKeyDown = function (event) {
                    if (event.keyCode === 13) {
                        scope.addNewValue();
                    }
                };
            },
            setupSingleValues: function (scope, element, removeDelay) {
                scope.disabledValue = {};
                scope.removeValue = function (index) {
                    scope.disabledValue[index] = true;
                    $timeout(function () {
                        scope.values.splice(index, 1);
                        scope.disabledValue[index] = false;
                    }, angular.isDefined(removeDelay) ? removeDelay : 300);
                };
                scope.onKeyDown = function (event, index) {
                    if (event.keyCode === 13) {
                        if (index < scope.values.length - 1) {
                            $(element).find('input')[index + 2].focus();
                        } else {
                            $(element).find('input')[0].focus();
                        }
                    }
                    if (event.keyCode === 8 && event.target.value === '') {
                        scope.removeValue(index);
                        event.preventDefault();
                    }
                };
            },
            setupNgModel: function (scope, element, ngModelCtrl, formCtrl) {
                ngModelCtrl.$render = function () {
                    scope.values = angular.copy(ngModelCtrl.$viewValue) || [];
                    scope.newValue = '';
                };
                var buildRemoveFunction = function (index) {
                    var remove = function () {
                        if (scope.values[index]) {
                            return;
                        }
                        if (!$(element.find('input')[index + 1]).is(':focus')) {
                            scope.removeValue(index);
                        } else {
                            $timeout(remove, 100);
                        }
                    };
                    return remove;
                };
                scope.$watch('values', function (nv, ov) {
                    if (angular.equals(nv, ov)) {
                        return;
                    }
                    var valid = true;
                    var i;
                    for (i = nv.length - 1; i >= 0; i--) {
                        if (!nv[i]) {
                            var removeIfNotFocus = buildRemoveFunction(i);
                            removeIfNotFocus();
                        }
                    }
                    if (nv.length === ov.length) {
                        var modified;
                        for (i = 0; i < nv.length; i++) {
                            if (nv[i] !== ov[i]) {
                                modified = i;
                            }
                        }
                        if (nv.indexOf(nv[modified]) < modified || nv.indexOf(nv[modified], modified + 1) > -1) {
                            formCtrl[scope.name + modified].$setValidity('unique', false);
                            valid = false;
                        }
                    }
                    if (valid) {
                        for (i = 0; i < nv.length; i++) {
                            if (nv.indexOf(nv[i], i + 1) > -1) {
                                valid = false;
                                break;
                            }
                        }
                    }
                    if (valid) {
                        for (i = 0; i < nv.length; i++) {
                            if (formCtrl[scope.name + i]) {
                                formCtrl[scope.name + i].$setValidity('unique', true);
                            }
                        }
                        d4cCustomInputHelper.setMainControlDirty(formCtrl, scope.name);
                        ngModelCtrl.$setViewValue(angular.copy(nv));
                    } else {
                        $rootScope.$broadcast(scope.id, {
                            event: 'save',
                            status: 'error'
                        });
                    }
                }, true);
            }
        };
    }]);
}());;
(function () {
    "use strict";
    var mod = angular.module('d4c.core');
    var D4CMimeType = function (mimetypeAsString) {
        this.type = undefined;
        this.subtype = undefined;
        this.extension = undefined;
        mimetypeAsString = mimetypeAsString ? mimetypeAsString.toLowerCase() : '*/*';
        if (mimetypeAsString.indexOf('.') === 0) {
            this.extension = mimetypeAsString.substr(1);
        } else {
            var elements = mimetypeAsString.split('/');
            this.type = elements[0];
            this.subtype = (this.type !== '*' && elements[1]) || '*';
        }
        this.match = function (file) {
            if (this.type === '*') {
                return true;
            }
            if (this.extension) {
                var extension = file.name.toLowerCase().split('.').pop();
                return this.extension === extension;
            }
            var mimetype = new D4CMimeType(file.type);
            return this.type === mimetype.type && (this.subtype === mimetype.subtype || this.subtype === '*');
        }
    };
    var D4CMimeTypeChecker = function (mimetypesAsString) {
        this.mimetypes = [];
        var that = this;
        mimetypesAsString = mimetypesAsString || '';
        angular.forEach(mimetypesAsString.split(/\s*,\s*/), function (mimetypeAsString) {
            that.mimetypes.push(new D4CMimeType(mimetypeAsString));
        });
        this.match = function (file) {
            if (!this.mimetypes.length) {
                return true;
            }
            return this.mimetypes.some(function (mimetype) {
                return mimetype.match(file);
            })
        };
    };
    mod.factory('D4CMimeType', function () {
        return D4CMimeType;
    });
    mod.factory('D4CMimeTypeChecker', function () {
        return D4CMimeTypeChecker;
    });
}());;
(function () {
    'use strict';
    var mod = angular.module('d4c.core');
    mod.factory('pollJobStatus', ['ManagementAPIV2', '$timeout', function (ManagementAPIV2, $timeout) {
        var pollJobStatus = function (jobUuid, callback, delay) {
            if (isNaN(delay)) {
                delay = 500;
            }
            ManagementAPIV2.jobs.get(jobUuid).success(function (response) {
                if (response.state === 'done' || response.state === 'error') {
                    callback(response);
                } else {
                    $timeout(function () {
                        pollJobStatus(jobUuid, callback, delay);
                    }, delay);
                }
            });
        };
        return pollJobStatus;
    }]);
}());;

function applied(fn, scope) {
    if (fn.wrappedInApply) {
        return fn;
    }
    var wrapped = function () {
        var args = arguments;
        var phase = scope.$root.$$phase;
        if (phase === "$apply" || phase === "$digest") {
            return fn.apply(null, args);
        } else {
            return scope.$apply(function () {
                return fn.apply(null, args);
            });
        }
    };
    wrapped.wrappedInApply = true;
    return wrapped;
}

function applyFunctions(obj, scope, propsConfig) {
    return Object.keys(obj || {}).reduce(function (prev, key) {
        var value = obj[key];
        var config = (propsConfig || {})[key] || {};
        prev[key] = angular.isFunction(value) && config.wrapApply !== false ? applied(value, scope) : value;
        return prev;
    }, {});
}

function watchProps(watchDepth, scope, watchExpressions, listener) {
    var supportsWatchCollection = angular.isFunction(scope.$watchCollection);
    var supportsWatchGroup = angular.isFunction(scope.$watchGroup);
    var watchGroupExpressions = [];
    watchExpressions.forEach(function (expr) {
        var actualExpr = getPropExpression(expr);
        var exprWatchDepth = getPropWatchDepth(watchDepth, expr);
        if (exprWatchDepth === 'collection' && supportsWatchCollection) {
            scope.$watchCollection(actualExpr, listener);
        } else if (exprWatchDepth === 'reference' && supportsWatchGroup) {
            watchGroupExpressions.push(actualExpr);
        } else {
            scope.$watch(actualExpr, listener, (exprWatchDepth !== 'reference'));
        }
    });
    if (watchGroupExpressions.length) {
        scope.$watchGroup(watchGroupExpressions, listener);
    }
}

function renderReactComponent(component, props, scope, elem) {
    scope.$evalAsync(function () {
        ngReact.render(component, props, elem[0]);
    });
}

function getPropName(prop) {
    return (Array.isArray(prop)) ? prop[0] : prop;
}

function getPropConfig(prop) {
    return (Array.isArray(prop)) ? prop[1] : {};
}

function getPropExpression(prop) {
    return (Array.isArray(prop)) ? prop[0] : prop;
}

function findAttribute(attrs, propName) {
    var index = Object.keys(attrs).filter(function (attr) {
        return attr.toLowerCase() === propName.toLowerCase();
    })[0];
    return attrs[index];
}

function getPropWatchDepth(defaultWatch, prop) {
    var customWatchDepth = (Array.isArray(prop) && angular.isObject(prop[1]) && prop[1].watchDepth);
    return customWatchDepth || defaultWatch;
}
angular.module('d4c.core').factory('d4cReactComponentFactory', function reactComponentFactory() {
    return function (componentName, props, conf, injectableProps) {
        return {
            restrict: 'E',
            priority: 9999,
            compile: function (tElem) {
                tElem.attr('ng-non-bindable');
                return function (scope, elem, attrs) {
                    var reactComponent = ngReact.components[componentName];
                    props = props || (Object.keys(reactComponent.propTypes || {}));
                    if (!props.length) {
                        var ngAttrNames = [];
                        angular.forEach(attrs.$attr, function (value, key) {
                            ngAttrNames.push(key);
                        });
                        props = ngAttrNames;
                    }
                    var propExpressions = props.map(function (prop) {
                        return (Array.isArray(prop)) ? [attrs[getPropName(prop)], getPropConfig(prop)] : attrs[prop];
                    });
                    var renderThisComponent = function () {
                        var scopeProps = {},
                            config = {};
                        props.forEach(function (prop) {
                            var propName = getPropName(prop);
                            scopeProps[propName] = scope.$eval(findAttribute(attrs, propName));
                            config[propName] = getPropConfig(prop);
                        });
                        scopeProps = applyFunctions(scopeProps, scope, config);
                        scopeProps = angular.extend({}, scopeProps, injectableProps);
                        renderReactComponent(reactComponent, scopeProps, scope, elem);
                    };
                    watchProps(attrs.watchDepth, scope, propExpressions, renderThisComponent);
                    renderThisComponent();
                    scope.$on('$destroy', function () {
                        ngReact.unmountComponentAtNode(elem[0]);
                    });
                };
            },
        };
    }
});;
(function () {
    'use strict';
    var app = angular.module('d4c.core');
    app.service('securityService', ['$rootScope', function ($rootScope) {
        var security = {};
        return {
            update: function (sec) {
                security = sec;
                $rootScope.$broadcast('securityDomainService', security);
            },
            retrieve: function () {
                return security;
            }
        };
    }]);
    app.factory('APIFileService', ['$q', '$rootScope', 'd4cNotificationService', 'DebugLogger', function ($q, $rootScope, d4cNotificationService, DebugLogger) {
        function getCookie(name) {
            var cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                var cookies = document.cookie.split(';');
                for (var i = 0; i < cookies.length; i++) {
                    var cookie = jQuery.trim(cookies[i]);
                    if (cookie.substring(0, name.length + 1) == (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        return function (url, file, callback, extraData) {
            var deferred = $q.defer();
            var xhr = new XMLHttpRequest();
            xhr.upload.addEventListener("progress", callback, false);
            xhr.addEventListener("load", function (e) {
                var target = e.target || e.srcElement;
                if (target.status == 200) {
                    deferred.resolve(target.response);
                } else {
                    deferred.reject(e);
                }
                $rootScope.$apply();
            }, false);
            xhr.addEventListener("error", function (e) {
                deferred.reject(e);
                $rootScope.$apply();
            }, false);
            xhr.open("POST", url);
            xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            xhr.setRequestHeader('X-CSRFToken', getCookie('csrftoken'));
            var formdata = new FormData();
            formdata.append("file", file);
            if (extraData) {
                angular.forEach(extraData, function (value, key) {
                    if (value) {
                        formdata.append(key, value);
                    }
                });
            }
            xhr.send(formdata);
            DebugLogger.log('%cPOST ' + url, "color: #999");
            return deferred.promise.then(function (reason) {
                return reason;
            }, function (reason) {
                try {
                    var data = angular.fromJson(reason.target.responseText);
                    if (data) {
                        d4cNotificationService.sendNotification(data);
                    }
                } catch (err) {}
                return $q.reject(reason);
            });
        };
    }]);
    app.factory("APIXHRService", ["$http", "DebugLogger", "d4cNotificationService", "d4cHttpErrorMessages", function ($http, DebugLogger, d4cNotificationService, d4cHttpErrorMessages) {
        return function (method, url, data, customHeaders, timeout) {
            var headers = {
                "Content-Type": "application/json"
            };
            if (customHeaders) {
                angular.extend(headers, customHeaders);
            }
            data = data || {};
            DebugLogger.log('%c' + method + ' ' + url, "color: #999");
            var options = {
                method: method,
                url: url,
                headers: headers,
                cache: false
            };
            if (timeout) {
                options.timeout = timeout;
            }
            if (method == 'GET') {
                options.params = data;
            } else {
                options.data = data;
            }
            var request = $http(options);
            request.error(function (data, status) {
                if (data) {
                    data._request = request;
                    if (data.error_key === "InvalidManagementAPIRequestException" && data.errors.length > 0) {
                        d4cNotificationService.sendNotification({
                            title: data.message,
                            type: 'error',
                            message: data.errors[0].message
                        });
                    } else {
                        d4cNotificationService.sendNotification(data);
                    }
                } else if (status >= 400) {
                    d4cNotificationService.sendNotification(d4cHttpErrorMessages.getForStatus(status));
                }
            });
            return request;
        };
    }]);
    app.factory("ManagementAPI", ["APIFileService", "APIXHRService", "$q", "$rootScope", 'config', 'DebugLogger', 'd4cNotificationService', function (APIFileService, APIXHRService, $q, $rootScope, config, DebugLogger, d4cNotificationService) {
        var API_PATH = '/api/management/1.0/';
        var assetUrlToFileName = function (url) {
            if (url.indexOf('/') > -1) {
                url = url.split('/')[url.split('/').length - 1];
            }
            return url;
        };
        return {
            'support': function (options) {
                return APIXHRService("POST", API_PATH + "support/", options);
            },
            'charts': {
                'new': function (title, chartData) {
                    return APIXHRService("POST", API_PATH + "charts/", {
                        'title': title,
                        'value': chartData
                    });
                },
                'list': function () {
                    return APIXHRService("GET", API_PATH + "charts/", {});
                },
                'lookup': function (chartId) {
                    return APIXHRService("GET", API_PATH + "charts/" + chartId + '/', {});
                },
                'update': function (chartId, title, chartData) {
                    return APIXHRService("POST", API_PATH + "charts/" + chartId + '/', {
                        'title': title,
                        'value': chartData
                    });
                },
                'delete': function (chartId) {
                    return APIXHRService("DELETE", API_PATH + "charts/" + chartId + '/', {});
                }
            },
            'map': {
                save: function (mapid, title, value) {
                    return APIXHRService("POST", API_PATH + "map/save/", {
                        'mapid': mapid,
                        'title': title,
                        'values': value
                    });
                },
                'delete': function (mapid) {
                    return APIXHRService("POST", API_PATH + "map/delete/" + mapid + "/");
                },
                list: function () {
                    return APIXHRService("GET", API_PATH + "map/");
                }
            },
            'users_suggest': function (options) {
                return APIXHRService("GET", API_PATH + "domain/users/suggest/", options);
            },
            'domain': {
                'get': function () {
                    return APIXHRService("GET", API_PATH + "domain/", {});
                },
                'update': function (updatedProperties) {
                    return APIXHRService("POST", API_PATH + "domain/update/", updatedProperties);
                },
                'groups': function (options) {
                    return APIXHRService("GET", API_PATH + "groups/", options);
                },
                'pages': function () {
                    return APIXHRService("GET", API_PATH + 'domain/pages/available', {});
                },
                'security': {
                    'get': function () {
                        return APIXHRService("GET", API_PATH + "security/", {});
                    },
                    'save': function (security) {
                        return APIXHRService("POST", API_PATH + "security/", security);
                    }
                },
                license: {
                    'status': function () {
                        return APIXHRService('GET', API_PATH + 'domain/license/');
                    }
                },
                accessrequests: {
                    'list': function () {
                        return APIXHRService("GET", API_PATH + "domain/accessrequests/");
                    },
                    'resolve': function (user_id, is_accepted, reason) {
                        return APIXHRService("POST", API_PATH + "domain/accessrequests/", {
                            user_id: user_id,
                            is_accepted: is_accepted,
                            reason: reason
                        });
                    }
                },
                'supported_processors': function () {
                    return APIXHRService("GET", API_PATH + "domain/supported_processors/", {});
                }
            },
            domain_theme: {
                'save': function (theme) {
                    return APIXHRService("POST", API_PATH + "domain_theme/", theme);
                },
                'get': function (version) {
                    return APIXHRService("GET", API_PATH + "domain_theme/" + version + '/');
                },
                'make_live': function (version) {
                    return APIXHRService("GET", API_PATH + "domain_theme/" + version + "/make_live/");
                },
                'get_apikey': function () {
                    return APIXHRService("GET", API_PATH + "domain_theme/apikey/");
                },
                'regenerate_apikey': function () {
                    return APIXHRService("POST", API_PATH + "domain_theme/apikey/");
                }
            },
            'external_service_check': function (parameters) {
                return APIXHRService("POST", API_PATH + "domain/verify_service_authentication", parameters);
            },
            'attachments': {
                'new': function (file, callback) {
                    return APIFileService(API_PATH + "attachments/", file, callback);
                }
            },
            'alternative_exports': {
                'new': function (file, callback) {
                    return APIFileService(API_PATH + "alternative_exports/", file, callback);
                }
            },
            'resources': {
                'fields': function (resource) {
                    return APIXHRService("POST", API_PATH + "resources/fields/", resource);
                },
                'preview': function (resource, nhits, options) {
                    nhits = nhits || 10;
                    options = options || {};
                    return APIXHRService("POST", API_PATH + "resources/preview/?nhits=" + nhits, resource, {}, options.timeout);
                },
                'config': function (resource) {
                    return APIXHRService("POST", API_PATH + "resources/config/", resource);
                },
                'supported_formats': function () {
                    return APIXHRService("GET", API_PATH + "resources/supported_formats/", {});
                },
                'new_realtime': function (callback) {
                    return APIXHRService("POST", API_PATH + "resources/new_realtime");
                },
                'new_file': function (file, callback) {
                    return APIFileService(API_PATH + "resources/", file, callback);
                },
                'new_text': function (text) {
                    return APIXHRService("POST", API_PATH + "resources/new_text", text);
                },
                'new_url': function (text) {
                    return APIXHRService("POST", API_PATH + "resources/new_url", text);
                }
            },
            'datasets': {
                'list': function (options) {
                    if (!options) {
                        options = {};
                    }
                    return APIXHRService("GET", API_PATH + "datasets/", options);
                },
                'preview': function (dataset, nhits, timeout) {
                    nhits = nhits || 10;
                    return APIXHRService("POST", API_PATH + "datasets/preview/?nhits=" + nhits, dataset, {}, timeout);
                },
                'show': function (id) {
                    return APIXHRService("GET", API_PATH + "datasets/" + id + "/", {});
                },
                'show_remote': function (dataset) {
                    return APIXHRService("POST", API_PATH + "datasets/remote/", dataset);
                },
                'show_remote_unverified': function (federation_parameters) {
                    return APIXHRService("POST", API_PATH + "datasets/remote_unverified/", federation_parameters);
                },
                'save': function (dataset) {
                    return APIXHRService("POST", API_PATH + "datasets/", dataset);
                },
                'delete': function (dataset) {
                    return APIXHRService("POST", API_PATH + "datasets/" + dataset.id + "/delete/");
                },
                'status': function (dataset) {
                    return APIXHRService("GET", API_PATH + "datasets/" + dataset.id + "/status/", {});
                },
                'versions': function (dataset) {
                    return APIXHRService("GET", API_PATH + "datasets/" + dataset.id + "/versions/", {});
                },
                'publish': function (dataset) {
                    return APIXHRService("POST", API_PATH + "datasets/" + dataset.id + "/publish/", dataset);
                },
                'records_errors': function (dataset, nhits) {
                    nhits = nhits || 100;
                    return APIXHRService("GET", API_PATH + "datasets/" + dataset.id + "/records_errors/?nhits=" + nhits);
                },
                'unpublish': function (dataset) {
                    return APIXHRService("POST", API_PATH + "datasets/" + dataset.id + "/unpublish/", dataset);
                },
                'rename': function (dataset, new_dataset_id) {
                    return APIXHRService("POST", API_PATH + "datasets/" + dataset.id + "/rename/", {
                        new_dataset_id: new_dataset_id
                    });
                },
                'copy': function (dataset) {
                    return APIXHRService("POST", API_PATH + "datasets/" + dataset.id + "/copy/", dataset);
                },
                'abort_publish': function (dataset) {
                    return APIXHRService("POST", API_PATH + "datasets/" + dataset.id + "/abort_publish/", dataset);
                },
                'security': {
                    'get': function (dataset) {
                        return APIXHRService("GET", API_PATH + "datasets/" + dataset.id + "/security/", {});
                    },
                    'save': function (dataset, security) {
                        return APIXHRService("POST", API_PATH + "datasets/" + dataset.id + "/security/", security);
                    }
                },
                'resources': {
                    'update_file': function (dataset, resource, file, callback) {
                        return APIFileService(API_PATH + 'datasets/' + dataset.id + "/resources/" + resource.id + "/update_file/", file, callback);
                    },
                    'enable': function (dataset, resource, callback) {
                        return APIXHRService("GET", API_PATH + 'datasets/' + dataset.id + "/resources/" + resource.id + "/enable/", callback);
                    },
                    'disable': function (dataset, resource, callback) {
                        return APIXHRService("GET", API_PATH + 'datasets/' + dataset.id + "/resources/" + resource.id + "/disable/", callback);
                    },
                    'scratchRecover': function (dataset, resource, callback) {
                        return APIXHRService("GET", API_PATH + 'datasets/' + dataset.id + "/resources/" + resource.id + "/recover/scratch/", callback);
                    },
                    'reindexRecover': function (dataset, resource, callback) {
                        return APIXHRService("GET", API_PATH + 'datasets/' + dataset.id + "/resources/" + resource.id + "/recover/", callback);
                    },
                    'cancelReindexRecover': function (dataset, resource, callback) {
                        return APIXHRService("GET", API_PATH + 'datasets/' + dataset.id + "/resources/" + resource.id + "/recover/cancel/", callback);
                    },
                    'generateApiKey': function (dataset, resource, callback) {
                        return APIXHRService("GET", API_PATH + 'datasets/' + dataset.id + '/resources/' + resource.id + '/api_keys/generate/', callback);
                    },
                    'getApiKeys': function (dataset, resource, callback) {
                        return APIXHRService("GET", API_PATH + 'datasets/' + dataset.id + '/resources/' + resource.id + '/api_keys/', callback);
                    },
                    'deleteApiKey': function (dataset, resource, key, callback) {
                        return APIXHRService("DELETE", API_PATH + 'datasets/' + dataset.id + '/resources/' + resource.id + '/api_keys/' + key + '/', callback);
                    },
                    'renewAPIKey': function (dataset, resource, key, callback) {
                        return APIXHRService("GET", API_PATH + 'datasets/' + dataset.id + '/resources/' + resource.id + '/api_keys/renew/' + key + '/', callback);
                    },
                    'cleanResourceCache': function (dataset, resource, key, callback) {
                        return APIXHRService("POST", API_PATH + 'datasets/' + dataset.id + '/resources/' + resource.id + '/clean_cache/', callback);
                    }
                },
                'processors_rewrite': function (processors, from_name, to_name) {
                    return APIXHRService("POST", API_PATH + "datasets/rename_processors/", {
                        processors: processors,
                        from_name: from_name,
                        to_name: to_name
                    });
                },
                'guess_processor_params': function (dataset) {
                    return APIXHRService("POST", API_PATH + "datasets/guess_processor_params/", dataset);
                },
                'snapshots': {
                    'save': function (dataset_id, description) {
                        return APIXHRService("POST", API_PATH + "datasets/" + dataset_id + "/snapshots/", {
                            description: description
                        });
                    },
                    'list': function (dataset_id) {
                        return APIXHRService("GET", API_PATH + "datasets/" + dataset_id + "/snapshots/", {});
                    },
                    'delete': function (dataset_id, snapshot_id) {
                        return APIXHRService("POST", API_PATH + "datasets/" + dataset_id + "/snapshots/" + snapshot_id + "/delete/", {});
                    }
                },
                'subscribers': {
                    'list': function (dataset_id) {
                        return APIXHRService("GET", API_PATH + "datasets/" + dataset_id + "/subscribers/", {});
                    },
                    'notify': function (dataset_id, content) {
                        return APIXHRService("POST", API_PATH + "datasets/" + dataset_id + "/subscribers/notify/", content);
                    }
                },
                'feedback': {
                    'list': function (dataset_id, options) {
                        return APIXHRService("GET", API_PATH + "datasets/" + dataset_id + "/feedback/", options);
                    },
                    'archive': function (dataset_id, feedback) {
                        return APIXHRService("POST", API_PATH + "datasets/" + dataset_id + "/feedback/archive/", feedback);
                    }
                }
            },
            'harvest': {
                'get': function (harvest_id) {
                    return APIXHRService("GET", API_PATH + 'harvesters/' + harvest_id + '/', {});
                },
                'list': function () {
                    return APIXHRService("GET", API_PATH + "harvesters/list/", {});
                },
                'available_harvesters': function () {
                    return APIXHRService("GET", API_PATH + "harvesters/available_harvesters/", {});
                },
                'update': function (harvesterparams) {
                    return APIXHRService("POST", API_PATH + 'harvesters/update/', harvesterparams);
                },
                'del': function (harvest_id) {
                    return APIXHRService('GET', API_PATH + 'harvesters/' + harvest_id + '/delete/', {});
                },
                'start': function (harvest_id) {
                    return APIXHRService('GET', API_PATH + 'harvesters/' + harvest_id + '/start/', {});
                },
                'publish': function (harvest_id) {
                    return APIXHRService('GET', API_PATH + 'harvesters/' + harvest_id + '/publish/', {});
                },
                'unpublish': function (harvest_id) {
                    return APIXHRService('GET', API_PATH + 'harvesters/' + harvest_id + '/unpublish/', {});
                },
                'detach': function (harvest_id) {
                    return APIXHRService('GET', API_PATH + 'harvesters/' + harvest_id + '/detach/', {});
                },
                'status': function () {
                    return APIXHRService("GET", API_PATH + 'harvesters/status/', {});
                },
                'abort': function (harvest_id) {
                    return APIXHRService("GET", API_PATH + 'harvesters/' + harvest_id + '/abort/', {});
                }
            },
            'metadata_templates': {
                'get': function (language) {
                    if (language) {
                        return APIXHRService("GET", API_PATH + "metadata_/sites/default/files/api/portail_d4c/templates/", {
                            'lang': language
                        });
                    } else {
                        return APIXHRService("GET", API_PATH + "metadata_/sites/default/files/api/portail_d4c/templates/", {});
                    }
                },
                'save': function (metadata_templates) {
                    return APIXHRService("POST", API_PATH + "metadata_/sites/default/files/api/portail_d4c/templates/", metadata_templates);
                },
                'suggest': function (template_name, meta_name, query) {
                    return APIXHRService("GET", API_PATH + "metadata_/sites/default/files/api/portail_d4c/templates/" + template_name + '/' + meta_name + '/suggest/', {
                        query: query
                    });
                }
            },
            'apiproxy': {
                'form_definition': function () {
                    return APIXHRService("GET", API_PATH + "apis/api_form_configuration/", {});
                },
                'config_wizard': function (api_config) {
                    return APIXHRService("POST", API_PATH + "apis/api_wizard/", api_config);
                },
                'swagger_specs': function (dataset) {
                    return APIXHRService("POST", API_PATH + "apis/api_doc/", dataset);
                }
            },
            'reuses': {
                'list': function () {
                    return APIXHRService('GET', API_PATH + 'reuses/', {});
                },
                'pending': function () {
                    return APIXHRService('GET', API_PATH + 'reuses/pending/', {});
                },
                'edit': function (reuse_id, data) {
                    return APIXHRService('POST', API_PATH + 'reuses/' + reuse_id + '/edit/', data);
                },
                'edit_url': function (reuse_id) {
                    return API_PATH + 'reuses/' + reuse_id + '/edit/';
                },
                'delete': function (reuse_id, data) {
                    return APIXHRService('POST', API_PATH + 'reuses/' + reuse_id + '/delete/', {});
                },
                'accept': function (reuse_id) {
                    return APIXHRService('POST', API_PATH + 'reuses/' + reuse_id + '/accept/', {});
                },
                'reject': function (reuse_id, data) {
                    return APIXHRService('POST', API_PATH + 'reuses/' + reuse_id + '/reject/', data);
                }
            },
            'assets': {
                'upload': function (asset_name, file, callback, properties) {
                    return APIFileService(API_PATH + 'assets/' + asset_name + '/', file, callback, {
                        'meta': properties
                    });
                },
                'uploadUrl': function (asset_name, filename) {
                    var url = API_PATH + 'assets/' + asset_name + '/';
                    if (filename) {
                        url += assetUrlToFileName(filename) + '/';
                    }
                    return url;
                },
                'remove': function (asset_name, filename) {
                    var url = API_PATH + 'assets/' + asset_name + '/delete/';
                    if (filename) {
                        url += assetUrlToFileName(filename) + '/';
                    }
                    return APIXHRService('POST', url);
                },
                'get': function (asset_name, filename) {
                    var url = API_PATH + 'assets/' + asset_name + '/';
                    if (filename) {
                        url += assetUrlToFileName(filename) + '/';
                    }
                    return APIXHRService('GET', url);
                }
            },
            subdomains: {
                list: function () {
                    return APIXHRService('GET', API_PATH + 'subdomains/', {});
                },
                create: function (subdomain) {
                    return APIXHRService('POST', API_PATH + 'subdomains/', subdomain);
                },
                get: function (subdomainId) {
                    return APIXHRService('GET', API_PATH + 'subdomains/' + subdomainId + '/', {});
                },
                'delete': function (subdomainId) {
                    return APIXHRService('DELETE', API_PATH + 'subdomains/' + subdomainId + '/', {});
                },
                related_domains: function (subdomainId) {
                    return APIXHRService('GET', API_PATH + 'subdomains/related_domains/', {});
                },
                quotas: {
                    get: function (subdomainId) {
                        return APIXHRService('GET', API_PATH + 'subdomains/' + subdomainId + '/quotas/');
                    },
                    update: function (subdomainId, quotas) {
                        return APIXHRService('POST', API_PATH + 'subdomains/' + subdomainId + '/quotas/', quotas);
                    }
                }
            }
        };
    }]);
    app.factory("ManagementAPIV2", ["APIFileService", "APIXHRService", function (APIFileService, APIXHRService) {
        var API_PATH_V2 = '/api/management/v2/';
        var getGroupIDs = function (groups) {
            var groupIDs = [];
            angular.forEach(groups, function (group) {
                groupIDs.push(group.group_id);
            });
            return groupIDs;
        };
        var getQuota = function (quota) {
            quota = quota || {};
            if (!isNullOrUndefined(quota.limit) && !quota.unit) {
                quota.unit = 'day';
            } else if (isNullOrUndefined(quota.limit)) {
                quota = {};
            }
            return quota;
        };
        var getLimits = function (sourceLimits) {
            if (!sourceLimits) {
                return {};
            }
            var limits = {};
            angular.forEach(['max_datasets', 'max_records_by_dataset'], function (limitName) {
                if (!isNullOrUndefined(sourceLimits[limitName])) {
                    limits[limitName] = sourceLimits[limitName];
                }
            });
            return limits;
        };
        var getBulkParameters = function (filters, ids) {
            var parameters = {
                'ids': ids
            };
            if (filters['search']) {
                parameters['search'] = filters['search'];
            }
            return parameters;
        };
        var cleanObject = function (object, propertyList) {
            var i;
            object = angular.copy(object);
            var keys = Object.keys(object);
            for (i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (propertyList.indexOf(key) === -1) {
                    delete object[key];
                }
            }
            for (i = 0; i < propertyList.length; i++) {
                if (!object.hasOwnProperty(propertyList[i])) {
                    object[propertyList[i]] = null;
                }
            }
            return object;
        };
        return {
            'content_packs': {
                'list': function () {
                    return APIXHRService('GET', API_PATH_V2 + 'content_packs/');
                },
                'unpack': function (name) {
                    return APIXHRService('PUT', API_PATH_V2 + 'unpack_content_pack/', {
                        name: name
                    });
                }
            },
            'files': {
                'new': function (file, callback) {
                    return APIFileService(API_PATH_V2 + "files/", file, callback);
                },
                'list': function () {
                    return APIXHRService('GET', API_PATH_V2 + 'files/')
                }
            },
            'jobs': {
                'get': function (jobUuid) {
                    return APIXHRService('GET', API_PATH_V2 + 'jobs/' + jobUuid);
                }
            },
            'datasets': {
                'abort': function (datasetUUID) {
                    return APIXHRService('PUT', API_PATH_V2 + 'datasets/' + datasetUUID + '/abort/');
                },
                'attachments': {
                    'delete': function (datasetUID, attachmentUID) {
                        return APIXHRService('DELETE', API_PATH_V2 + 'datasets/' + datasetUID + '/attachments/' + attachmentUID)
                    },
                    'list': function (datasetUID) {
                        return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/attachments/');
                    },
                    'new': function (datasetUID, fileURL) {
                        return APIXHRService('POST', API_PATH_V2 + "datasets/" + datasetUID + '/attachments/', {
                            url: fileURL
                        });
                    }
                },
                'changes': function (datasetUUID) {
                    return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUUID + '/changes/');
                },
                'metadata': {
                    'list': function (datasetUID) {
                        return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/metadata/');
                    },
                    'get': function (datasetUID, metadataTemplateName, metadataName) {
                        return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/metadata/' + metadataTemplateName + '/' + metadataName + '/');
                    },
                    'update': function (datasetUID, metadataTemplateName, metadataName, value, overrideRemoteValue) {
                        return APIXHRService('PUT', API_PATH_V2 + 'datasets/' + datasetUID + '/metadata/' + metadataTemplateName + '/' + metadataName + '/', {
                            value: value,
                            override_remote_value: overrideRemoteValue
                        });
                    }
                },
                'new': function (title) {
                    return APIXHRService('POST', API_PATH_V2 + 'datasets/', {
                        metas: {
                            default: {
                                title: title
                            }
                        }
                    });
                },
                'outputFields': {
                    'get': function (datasetUID) {
                        return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/output_fields/');
                    }
                },
                'publish': function (datasetUUID) {
                    return APIXHRService('PUT', API_PATH_V2 + 'datasets/' + datasetUUID + '/publish/');
                },
                'restoreChange': function (datasetUUID, changeId) {
                    return APIXHRService('PUT', API_PATH_V2 + 'datasets/' + datasetUUID + '/restore_change/' + changeId + '/');
                },
                'resources': {
                    'list': function (datasetUID) {
                        return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/resources/');
                    }
                },
                'schedules': {
                    'list': function (datasetUID) {
                        return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/schedules/');
                    },
                    'new': function (datasetUID, schedule) {
                        return APIXHRService('POST', API_PATH_V2 + 'datasets/' + datasetUID + '/schedules/', schedule);
                    },
                    'get': function (datasetUID, scheduleUID) {
                        return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/schedules/' + scheduleUID + '/');
                    },
                    'update': function (datasetUID, schedule) {
                        return APIXHRService('PUT', API_PATH_V2 + 'datasets/' + datasetUID + '/schedules/' + schedule.schedule_uid + '/', schedule);
                    },
                    'delete': function (datasetUID, scheduleUID) {
                        return APIXHRService('DELETE', API_PATH_V2 + 'datasets/' + datasetUID + '/schedules/' + scheduleUID + '/');
                    }
                },
                'security': {
                    'accessPolicy': {
                        'get': function (datasetUID) {
                            return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/security/access_policy/');
                        },
                        'update': function (datasetUID, accessPolicy) {
                            return APIXHRService('PUT', API_PATH_V2 + 'datasets/' + datasetUID + '/security/access_policy/', JSON.stringify(accessPolicy));
                        }
                    },
                    'default': {
                        'get': function (datasetUID) {
                            return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/security/default/');
                        },
                        'update': function (datasetUID, defaultSecurity) {
                            return APIXHRService('PUT', API_PATH_V2 + 'datasets/' + datasetUID + '/security/default/', defaultSecurity);
                        }
                    },
                    'users': {
                        'list': function (datasetUID) {
                            return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/security/users/', {
                                expand: 'user'
                            });
                        },
                        'new': function (datasetUID, ruleset) {
                            var data = cleanObject(ruleset, ['permissions', 'visible_fields', 'is_data_visible', 'filter_query', 'api_calls_quota', 'user']);
                            return APIXHRService('POST', API_PATH_V2 + 'datasets/' + datasetUID + '/security/users/', data);
                        },
                        'delete': function (datasetUID, username) {
                            return APIXHRService('DELETE', API_PATH_V2 + 'datasets/' + datasetUID + '/security/users/' + username + '/');
                        },
                        'update': function (datasetUID, username, ruleset) {
                            var data = cleanObject(ruleset, ['permissions', 'visible_fields', 'is_data_visible', 'filter_query', 'api_calls_quota']);
                            return APIXHRService('PUT', API_PATH_V2 + 'datasets/' + datasetUID + '/security/users/' + username + '/', data);
                        }
                    },
                    'groups': {
                        'list': function (datasetUID) {
                            return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUID + '/security/groups/', {
                                expand: 'group'
                            });
                        },
                        'new': function (datasetUID, ruleset) {
                            var data = cleanObject(ruleset, ['permissions', 'visible_fields', 'is_data_visible', 'filter_query', 'api_calls_quota', 'group']);
                            return APIXHRService('POST', API_PATH_V2 + 'datasets/' + datasetUID + '/security/groups/', data);
                        },
                        'delete': function (datasetUID, group_id) {
                            return APIXHRService('DELETE', API_PATH_V2 + 'datasets/' + datasetUID + '/security/groups/' + group_id + '/');
                        },
                        'update': function (datasetUID, group_id, ruleset) {
                            var data = cleanObject(ruleset, ['permissions', 'visible_fields', 'is_data_visible', 'filter_query', 'api_calls_quota']);
                            return APIXHRService('PUT', API_PATH_V2 + 'datasets/' + datasetUID + '/security/groups/' + group_id + '/', data);
                        }
                    }
                },
                'status': function (datasetUUID) {
                    return APIXHRService('GET', API_PATH_V2 + 'datasets/' + datasetUUID + '/status/', {
                        expand: 'datasetid'
                    });
                },
                'unpublish': function (datasetUUID) {
                    return APIXHRService('PUT', API_PATH_V2 + 'datasets/' + datasetUUID + '/unpublish/');
                }
            },
            'users': {
                'list': function (searchParams) {
                    searchParams = searchParams || {};
                    if (angular.isArray(searchParams.permissions)) {
                        searchParams.permissions = searchParams.permissions.join(',');
                    }
                    if (!searchParams.permissions) {
                        delete searchParams.permissions;
                    }
                    return APIXHRService('GET', API_PATH_V2 + 'users/', searchParams);
                },
                'invite': function (emails) {
                    emails = angular.isString(emails) ? [emails] : emails;
                    return APIXHRService('POST', API_PATH_V2 + 'users/', {
                        emails: emails
                    });
                },
                'lookup': function (username) {
                    return APIXHRService('GET', API_PATH_V2 + 'users/' + username + '/', {});
                },
                'delete': function (username) {
                    return APIXHRService('DELETE', API_PATH_V2 + 'users/' + username + '/', {});
                },
                'update': function (username, userData) {
                    var user = {
                        permissions: userData.permissions || [],
                        group_ids: userData.group_ids || getGroupIDs(userData.groups),
                        quotas: getQuota(userData.quotas),
                        limits: getLimits(userData.limits)
                    };
                    return APIXHRService('PUT', API_PATH_V2 + 'users/' + username + '/', user);
                },
                'removePermissions': function (username, permissions) {
                    if (angular.isString(permissions)) {
                        permissions = [permissions];
                    }
                    return APIXHRService('DELETE', API_PATH_V2 + 'users/' + username + '/permissions/', {
                        permissions: permissions
                    });
                },
                'addPermissions': function (username, permissions) {
                    if (angular.isString(permissions)) {
                        permissions = [permissions];
                    }
                    return APIXHRService('POST', API_PATH_V2 + 'users/' + username + '/permissions/', {
                        permissions: permissions
                    });
                },
                'removeFromGroups': function (username, group_ids) {
                    if (angular.isString(group_ids)) {
                        group_ids = [group_ids];
                    }
                    return APIXHRService('DELETE', API_PATH_V2 + 'users/' + username + '/groups/', {
                        group_ids: group_ids
                    });
                },
                'addToGroups': function (username, group_ids) {
                    if (angular.isString(group_ids)) {
                        group_ids = [group_ids];
                    }
                    return APIXHRService('POST', API_PATH_V2 + 'users/' + username + '/groups/', {
                        group_ids: group_ids
                    });
                }
            },
            'groups': {
                'list': function () {
                    return APIXHRService('GET', API_PATH_V2 + 'groups/', {});
                },
                'new': function (title) {
                    return APIXHRService('POST', API_PATH_V2 + 'groups/', {
                        title: title
                    });
                },
                'lookup': function (groupId) {
                    return APIXHRService('GET', API_PATH_V2 + 'groups/' + groupId + '/', {});
                },
                'update': function (groupId, groupData) {
                    var group = {
                        title: groupData.title,
                        permissions: groupData.permissions || [],
                        quotas: getQuota(groupData.quotas),
                        limits: getLimits(groupData.limits)
                    };
                    return APIXHRService('PUT', API_PATH_V2 + 'groups/' + groupId + '/', group);
                },
                'delete': function (groupId) {
                    return APIXHRService('DELETE', API_PATH_V2 + 'groups/' + groupId + '/', {});
                },
                'removePermissions': function (groupId, permissions) {
                    if (angular.isString(permissions)) {
                        permissions = [permissions];
                    }
                    return APIXHRService('DELETE', API_PATH_V2 + 'groups/' + groupId + '/permissions/', {
                        permissions: permissions
                    });
                },
                'addPermissions': function (groupId, permissions) {
                    if (angular.isString(permissions)) {
                        permissions = [permissions];
                    }
                    return APIXHRService('POST', API_PATH_V2 + 'groups/' + groupId + '/permissions/', {
                        permissions: permissions
                    });
                },
                'users': {
                    'list': function (groupId, searchParams) {
                        searchParams = searchParams || {};
                        return APIXHRService('GET', API_PATH_V2 + 'groups/' + groupId + '/users/', searchParams);
                    },
                    'new': function (groupId, usernames) {
                        usernames = angular.isArray(usernames) ? usernames : [usernames];
                        return APIXHRService('POST', API_PATH_V2 + 'groups/' + groupId + '/users/', {
                            'usernames': usernames
                        });
                    },
                    'delete': function (groupId, username) {
                        return APIXHRService('DELETE', API_PATH_V2 + 'groups/' + groupId + '/users/' + username + '/', {});
                    }
                }
            },
            'accessRequests': {
                'list': function () {
                    return APIXHRService('GET', API_PATH_V2 + 'access_requests/', {});
                },
                'approve': function (accessRequestId) {
                    return APIXHRService('PUT', API_PATH_V2 + 'access_requests/' + accessRequestId + '/approve/', {});
                },
                'reject': function (accessRequestId) {
                    return APIXHRService('PUT', API_PATH_V2 + 'access_requests/' + accessRequestId + '/reject/', {});
                }
            },
            'subdomains': {
                'list': function (searchParams) {
                    searchParams = searchParams || {};
                    return APIXHRService('GET', API_PATH_V2 + 'subdomains/', searchParams);
                },
                'create': function (subdomain) {
                    return APIXHRService('POST', API_PATH_V2 + 'subdomains/', subdomain);
                },
                'get': function (subdomainId) {
                    return APIXHRService('GET', API_PATH_V2 + 'subdomains/' + subdomainId + '/', {});
                },
                'delete': function (subdomainId) {
                    return APIXHRService('DELETE', API_PATH + 'subdomains/' + subdomainId + '/', {});
                },
                'update': function (subdomain) {
                    return APIXHRService('PUT', API_PATH_V2 + 'subdomains/' + encodeURIComponent(subdomain.id) + '/', subdomain);
                },
                'settings': {
                    'get': function () {
                        return APIXHRService('GET', API_PATH_V2 + 'subdomains/settings/', {});
                    },
                    'update': function (properties) {
                        return APIXHRService('POST', API_PATH_V2 + 'subdomains/settings/', properties);
                    }
                },
                'bulk': {
                    'pushContent': function (filters, subdomains, content) {
                        return APIXHRService('PATCH', API_PATH_V2 + 'subdomains/', Object.assign({}, getBulkParameters(filters, subdomains), {
                            'datasets': content['datasets'] || [],
                            'pages': content['pages'] || []
                        }));
                    },
                    'delete': function (filters, subdomains) {
                        return APIXHRService('DELETE', API_PATH_V2 + 'subdomains/', getBulkParameters(filters, subdomains));
                    }
                }
            },
            'pages': {
                'bulk': {
                    'delete': function (search, pages) {
                        return APIXHRService('DELETE', API_PATH_V2 + 'pages/' + (search ? '?search=' + encodeURIComponent(search) : ''), pages);
                    }
                },
                'get': function (slug) {
                    return APIXHRService('GET', API_PATH_V2 + 'pages/' + slug);
                },
                'list': function (searchParams) {
                    searchParams = searchParams || {};
                    if (angular.isArray(searchParams.permissions)) {
                        searchParams.permissions = searchParams.permissions.join(',');
                    }
                    if (!searchParams.permissions) {
                        delete searchParams.permissions;
                    }
                    return APIXHRService('GET', API_PATH_V2 + 'pages/', searchParams);
                },
                'delete': function (pageId) {
                    return APIXHRService('DELETE', API_PATH_V2 + 'pages/' + pageId + '/', {});
                },
                create: function (page) {
                    return APIXHRService("POST", API_PATH_V2 + 'pages/', page);
                },
                'isValidTitle': function (title, language) {
                    var deferred = $q.defer();
                    this.list().then(function (list) {
                        var valid = true;
                        for (var i = 0; i < list.length; i++) {
                            if (list[i].title[language] === title) {
                                valid = false;
                                break;
                            }
                        }
                        deferred.resolve(valid);
                    }, function (reason) {
                        deferred.reject(reason);
                    });
                    return deferred.promise;
                },
                'groups': {
                    'delete': function (slug, groupId) {
                        return APIXHRService('DELETE', API_PATH_V2 + 'pages/' + slug + '/security/groups/' + groupId);
                    },
                    'list': function (slug) {
                        return APIXHRService('GET', API_PATH_V2 + 'pages/' + slug + '/security/groups?expand=group');
                    },
                    'new': function (slug, groupId, permissions) {
                        return APIXHRService('POST', API_PATH_V2 + 'pages/' + slug + '/security/groups', {
                            group: {
                                group_id: groupId
                            },
                            permissions: permissions
                        });
                    },
                    'update': function (slug, groupId, permissions) {
                        return APIXHRService('PUT', API_PATH_V2 + 'pages/' + slug + '/security/groups/' + groupId, {
                            permissions: permissions
                        });
                    }
                },
                'save': function (pageId, page) {
                    return APIXHRService("PUT", API_PATH_V2 + 'pages/' + pageId + '/', page);
                },
                'users': {
                    'delete': function (slug, username) {
                        return APIXHRService('DELETE', API_PATH_V2 + 'pages/' + slug + '/security/users/' + username);
                    },
                    'list': function (slug) {
                        return APIXHRService('GET', API_PATH_V2 + 'pages/' + slug + '/security/users?expand=user');
                    },
                    'new': function (slug, username, permissions) {
                        return APIXHRService('POST', API_PATH_V2 + 'pages/' + slug + '/security/users', {
                            user: {
                                username: username
                            },
                            permissions: permissions
                        });
                    },
                    'update': function (slug, username, permissions) {
                        return APIXHRService('PUT', API_PATH_V2 + 'pages/' + slug + '/security/users/' + username, {
                            permissions: permissions
                        });
                    }
                }
            },
            'harvesters': {
                'create': function (harvester) {
                    return APIXHRService('POST', API_PATH_V2 + 'harvesters/', harvester);
                },
                'preview': function (harvester_id, params) {
                    return APIXHRService('POST', API_PATH_V2 + 'harvesters/' + harvester_id + '/preview/', {
                        params: params
                    });
                },
                'start': function (harvester_id) {
                    return APIXHRService('PUT', API_PATH_V2 + 'harvesters/' + harvester_id + '/start/');
                },
                'publish': function (harvester_id) {
                    return APIXHRService('PUT', API_PATH_V2 + 'harvesters/' + harvester_id + '/publish/');
                },
                'unpublish': function (harvester_id) {
                    return APIXHRService('PUT', API_PATH_V2 + 'harvesters/' + harvester_id + '/unpublish/');
                },
                'errors': function (harvester_id) {
                    return APIXHRService('GET', API_PATH_V2 + 'harvesters/' + harvester_id + '/errors/');
                },
                'abort': function (harvester_id) {
                    return APIXHRService('PUT', API_PATH_V2 + 'harvesters/' + harvester_id + '/abort/');
                },
                'delete': function (harvester_id, delete_attached_datasets) {
                    return APIXHRService('DELETE', API_PATH_V2 + 'harvesters/' + harvester_id + '/?delete_attached_datasets=' + delete_attached_datasets);
                },
                'update': function (harvester_id, harvester) {
                    harvester = angular.copy(harvester);
                    delete harvester.status;
                    delete harvester.has_errors;
                    delete harvester.created_at;
                    delete harvester.harvester_id;
                    delete harvester.last_modified_by;
                    delete harvester.last_modified_at;
                    delete harvester.last_started_at;
                    delete harvester.last_success_at;
                    delete harvester.counters;
                    delete harvester.errors;
                    delete harvester.fetcher;
                    return APIXHRService('PUT', API_PATH_V2 + 'harvesters/' + harvester_id + '/', harvester);
                },
                'types': function () {
                    return APIXHRService('GET', API_PATH_V2 + 'harvester_types/');
                },
                'list': function () {
                    return APIXHRService('GET', API_PATH_V2 + 'harvesters/');
                }
            },
            'authorizedMetadata': {
                'list': function () {
                    return APIXHRService('GET', API_PATH_V2 + 'authorized_metadata/');
                }
            }
        };
    }]);
    app.factory("SearchAPI", ["APIXHRService", "config", function (APIXHRService, config) {
        var API_PATH = '/api/';
        var customHeaders = {};
        var timezone = jstz.determine().name();
        var timezoneAwareOptions = function (options) {
            options = options || {};
            //options.timezone = timezone;
            return options;
        };
        return {
            setApplication: function (appName) {
                customHeaders["D4C-API-Analytics-App"] = appName;
            },
            setCustomHeaders: function (headers) {
                angular.extend(customHeaders, headers);
            },
            persist: {
                map: function (mapid, title, value) {
                    return APIXHRService("POST", "/map" + API_PATH + "save/", {
                        'mapid': mapid,
                        'title': title,
                        'values': value
                    });
                }
            },
            datasets: {
                'lookup': function (datasetId, options) {
                    return APIXHRService("GET", API_PATH + 'datasets/1.0/' + datasetId + '/', timezoneAwareOptions(options), customHeaders);
                },
                'search': function (options) {
                    return APIXHRService("GET", API_PATH + 'datasets/1.0/search/', timezoneAwareOptions(options), customHeaders);
                },
                'attachmentURL': function (attachment) {
                    return API_PATH + 'datasets/1.0/' + config.ID_DATASET + '/attachments/' + attachment.id + '/';
                },
                'feedback': function (datasetId, data) {
                    return APIXHRService('POST', API_PATH + 'datasets/1.0/' + datasetId + '/feedback/', data);
                },
                'specifications': function (datasetId, type, format) {
                    return APIXHRService('GET', '/service/specifications/' + datasetId + '/' + type + '.' + format);
                }
            },
            records: {
                'search': function (options) {
                    return APIXHRService("GET", API_PATH + 'records/1.0/search/', timezoneAwareOptions(options), customHeaders);
                },
                'download': function (options) {
                    return APIXHRService("GET", API_PATH + 'records/1.0/download/', timezoneAwareOptions(options), customHeaders);
                },
                'analyze': function (options) {
                    return APIXHRService("GET", API_PATH + 'records/1.0/analyze/', timezoneAwareOptions(options), customHeaders);
                },
                'geo': function (options, timeout) {
                    return APIXHRService("GET", API_PATH + 'records/1.0/geocluster/', timezoneAwareOptions(options), customHeaders, timeout);
                },
                'geopreview': function (options, timeout) {
                    return APIXHRService("GET", API_PATH + 'records/1.0/geopreview/', timezoneAwareOptions(options), customHeaders, timeout);
                },
                'geopolygon': function (options, timeout) {
                    return APIXHRService("GET", API_PATH + 'records/1.0/geopolygon/', timezoneAwareOptions(options), customHeaders, timeout);
                },
                'boundingbox': function (options, timeout) {
                    return APIXHRService("GET", API_PATH + 'records/1.0/boundingbox/', timezoneAwareOptions(options), customHeaders, timeout);
                }
            },
            metadata: {
                'basic': function () {
                    return APIXHRService("GET", API_PATH + 'metadata/1.0/basic/', {}, customHeaders);
                },
                'interop': function () {
                    return APIXHRService("GET", API_PATH + 'metadata/1.0/interop/', {}, customHeaders);
                },
                'extra': function () {
                    return APIXHRService("GET", API_PATH + 'metadata/1.0/extra/', {}, customHeaders);
                }
            },
            snapshots: {
                'list': function (dataset_id) {
                    return APIXHRService('GET', API_PATH + 'datasets/1.0/' + dataset_id + '/snapshots/', {}, customHeaders);
                }
            },
            services: {
                'list': function (dataset_id) {
                    return APIXHRService('GET', API_PATH + 'datasets/1.0/' + dataset_id + '/services/', {}, customHeaders);
                }
            }
        };
    }]);
    app.factory('PlatformAPI', ['APIXHRService', 'config', function (APIXHRService, config) {
        var API_PATH = '/api/platform/1.0/';
        return {
            domains: {
                'delete': function (domain) {
                    return APIXHRService('POST', API_PATH + 'domains/' + domain.id + '/delete/' + domain);
                },
                'new': function (domain) {
                    return APIXHRService('POST', API_PATH + 'domains/', domain);
                },
                'save': function (domain_id, isNew, domain, firstUser) {
                    return APIXHRService('POST', API_PATH + 'domains/' + domain_id + '/', {
                        'is_new': isNew,
                        'domain': domain,
                        'first_user': firstUser
                    });
                },
                'get': function (domain_id) {
                    return APIXHRService('GET', API_PATH + 'domains/' + domain_id + '/');
                },
                'statuses': function () {
                    return APIXHRService('GET', API_PATH + 'domains/statuses/', {});
                },
                'refresh': function () {
                    return APIXHRService('POST', API_PATH + 'domains/refresh/', {});
                },
                'idValidAndAvailable': function (domainId) {
                    return APIXHRService('GET', API_PATH + 'domains/' + domainId + '/valid/');
                },
                license: {
                    'infos': function () {
                        return APIXHRService('GET', API_PATH + 'domains/license/');
                    },
                },
                aliases: {
                    'lookup': function (domainId) {
                        return APIXHRService('GET', API_PATH + 'domains/' + domainId + '/enumerate_aliases/');
                    }
                },
                url_rewrites: {
                    'lookup': function (domainId) {
                        return APIXHRService('GET', API_PATH + 'domains/' + domainId + '/enumerate_url_rewrites/');
                    }
                },
                ip_whitelist: {
                    'lookup': function (domainId) {
                        return APIXHRService('GET', API_PATH + 'domains/' + domainId + '/enumerate_full_ip_whitelist/');
                    }
                }
            },
            suggest: {
                'all': function (options) {
                    return APIXHRService('GET', API_PATH + 'suggest/all/', options);
                }
            },
            resources: {
                'enumerate_extractors': function () {
                    return APIXHRService("GET", API_PATH + "resources/enumerate_extractors/", {});
                },
                'enumerate_processors': function () {
                    return APIXHRService("GET", API_PATH + "resources/enumerate_processors/", {});
                },
                'enumerate_harvesters': function () {
                    return APIXHRService("GET", API_PATH + "resources/enumerate_harvesters/", {});
                }
            },
            user: {
                'save': function (user) {
                    return APIXHRService("POST", API_PATH + "user/", user);
                },
                'send_email': function (user) {
                    return APIXHRService("POST", API_PATH + "user/email/", user);
                },
                'suggest': function (options) {
                    return APIXHRService("GET", API_PATH + "user/suggest/", options);
                },
                'get': function (user_name) {
                    return APIXHRService("GET", API_PATH + "user/", {
                        "id": user_name
                    });
                }
            }
        };
    }]);
    app.factory('CoreAPI', ['APIXHRService', 'config', function (APIXHRService, config) {
        var API_PATH = '/api/';
        return {
            'account': {
                'get': function () {
                    return APIXHRService("GET", API_PATH + "account/", {});
                },
                'save_details': function (user) {
                    return APIXHRService("POST", API_PATH + "account/details/", user);
                },
                'save_password': function (pass) {
                    return APIXHRService("POST", API_PATH + "account/password/", pass);
                },
                'save_email': function (email) {
                    return APIXHRService("POST", API_PATH + "account/email/", {
                        'new_email': email
                    });
                },
                'datasets_index_filters': {
                    'lookup': function () {
                        return APIXHRService("GET", API_PATH + "account/datasets_index_filters/");
                    },
                    'update': function (datasets_index_filters) {
                        return APIXHRService("PUT", API_PATH + "account/datasets_index_filters/", {
                            'datasets_index_filters': datasets_index_filters
                        });
                    }
                },
                'api_key': {
                    'list': function () {
                        return APIXHRService("GET", API_PATH + "account/apikeys/");
                    },
                    'generate': function () {
                        return APIXHRService("POST", API_PATH + "account/apikey/generate/");
                    },
                    'lookup': function (key) {
                        return APIXHRService("GET", API_PATH + "account/apikey/" + key + "/");
                    },
                    'update': function (key, params) {
                        return APIXHRService("POST", API_PATH + "account/apikey/" + key + "/", params);
                    },
                    'revoke': function (key) {
                        return APIXHRService("DELETE", API_PATH + "account/apikey/" + key + "/");
                    }
                },
                'quota': {
                    'get': function () {
                        return APIXHRService("GET", API_PATH + "account/quota/");
                    }
                },
                'subscriptions': {
                    'datasets': {
                        'subscribe': function (datasetId) {
                            return APIXHRService("POST", API_PATH + "account/subscriptions/datasets/" + datasetId + "/subscribe/");
                        },
                        'unsubscribe': function (datasetId) {
                            return APIXHRService("POST", API_PATH + "account/subscriptions/datasets/" + datasetId + "/unsubscribe/");
                        }
                    },
                    'notifications': {
                        'list': function () {
                            return APIXHRService("GET", API_PATH + "account/subscriptions/notifications/");
                        },
                        'subscribe': function (notificationName) {
                            return APIXHRService("POST", API_PATH + "account/subscriptions/notifications/" + notificationName + "/subscribe/");
                        },
                        'unsubscribe': function (notificationName) {
                            return APIXHRService("POST", API_PATH + "account/subscriptions/notifications/" + notificationName + "/unsubscribe/");
                        }
                    },
                    'newsletter': {
                        'get': function () {
                            return APIXHRService("GET", API_PATH + "account/subscriptions/newsletter/");
                        },
                        'language': function (language) {
                            return APIXHRService("POST", API_PATH + "account/subscriptions/newsletter/language/", {
                                'language': language
                            });
                        },
                        'subscribe': function (newsletterName) {
                            return APIXHRService("POST", API_PATH + "account/subscriptions/newsletter/" + newsletterName + "/subscribe/", {});
                        },
                        'unsubscribe': function (newsletterName) {
                            return APIXHRService("POST", API_PATH + "account/subscriptions/newsletter/" + newsletterName + "/unsubscribe/", {});
                        }
                    }
                },
                'sso_identities': {
                    'list': function () {
                        return APIXHRService("GET", API_PATH + "account/identities/");
                    },
                    'revoke': function (identityId) {
                        return APIXHRService("DELETE", API_PATH + "account/identity/" + identityId + "/");
                    }
                },
                'onboardings': {
                    'done': function (onboarding_id) {
                        return APIXHRService("POST", API_PATH + "account/onboardings/" + onboarding_id + "/");
                    }
                }
            },
            'oauth2': {
                'applications': {
                    'list': function () {
                        return APIXHRService("GET", API_PATH + "oauth2/applications/");
                    },
                    'add': function (application) {
                        return APIXHRService("POST", API_PATH + "oauth2/applications/", application);
                    },
                    'remove': function (applicationId) {
                        return APIXHRService("POST", API_PATH + "oauth2/applications/" + applicationId + "/remove/");
                    }
                },
                'grants': {
                    'list': function () {
                        return APIXHRService("GET", API_PATH + "oauth2/grants/");
                    },
                    'revoke': function (applicationId) {
                        return APIXHRService("POST", API_PATH + "oauth2/grants/" + applicationId + "/revoke/");
                    }
                }
            }
        };
    }]);
    app.factory('PageAPI', ['APIXHRService', '$q', 'config', function (APIXHRService) {
        var API_PATH = '/api/v2/pages/';
        return {
            contact: function (slug, data) {
                return APIXHRService("POST", API_PATH + slug + '/contact/', data);
            },
            list: function () {
                return APIXHRService("GET", API_PATH, {});
            },
            lookup: function (slug) {
                return APIXHRService("GET", API_PATH + slug, {});
            }
        };
    }]);
    app.factory('MapbuilderAPI', ['APIXHRService', '$q', 'config', function (APIXHRService) {
        var API_PATH = '/api/mapbuilder/';
        return {
            create: function (data) {
                return APIXHRService("POST", API_PATH, data);
            },
            save: function (mapId, data) {
                return APIXHRService("PUT", API_PATH + mapId + '/', data);
            },
            get: function (mapId) {
                return APIXHRService("GET", API_PATH + mapId + '/');
            },
            list: function () {
                return APIXHRService("GET", API_PATH);
            },
            'delete': function (mapId) {
                return APIXHRService("DELETE", API_PATH + mapId + '/');
            }
        };
    }]);
    app.factory('ReuseAPI', ['APIXHRService', 'config', function (APIXHRService, config) {
        var API_PATH = '/api/datasets/1.0/';
        return {
            'list': function () {
                return APIXHRService('GET', API_PATH + config.ID_DATASET + '/reuses/', {});
            },
            'save': function (data) {
                return APIXHRService('POST', API_PATH + config.ID_DATASET + '/reuses/', data);
            },
            'save_url': API_PATH + config.ID_DATASET + '/reuses/'
        };
    }]);
    app.factory("DebugLogger", ['$window', 'config', function ($window, config) {
        return {
            log: function () {
                if (config.FORCE_DEBUG_LOGGER || $window.location.hash == '#debug' || $window.location.hash.indexOf('debug=') >= 0 || $(document.body).hasClass('showDebug')) {
                    console.log.apply(console, arguments);
                }
            }
        };
    }]);
    app.factory('AssetHelper', ['$q', 'd4cNotificationService', 'APIFileService', 'translate', function ($q, d4cNotificationService, APIFileService, translate) {
        var getFullMessage = function (message, extra) {
            message = translate(message);
            return extra ? message.substr(0, message.length - 1) + ' (max ' + extra + ')' + message.substr(message.length - 1) : message;
        };
        var getMaxDimensions = function (config) {
            return config.max_width + 'x' + config.max_height;
        };
        var getMaxSize = function (config) {
            if (config.max_size > Math.pow(1024, 2)) {
                return Math.round(config.max_size / Math.pow(1024, 2) * 10) / 10 + ' Mo';
            }
            return Math.round(config.max_size / 1024) + ' Ko';
        };
        var sizeAllowed = function (config, file) {
            return file.size <= config.max_size;
        };
        return {
            post: function (url, file, config, extraData, callback) {
                var deferred = $q.defer();
                if (!file || (file && sizeAllowed(config, file))) {
                    APIFileService(url, file, callback, extraData).then(function (data) {
                        data = angular.fromJson(data);
                        deferred.resolve(data);
                    }, function (data) {
                        if (data.target.responseText) {
                            data = angular.fromJson(data.target.responseText);
                            data.error = $.inArray(data.errorcode, [70001, 70002]) >= 0 ? getFullMessage(data.error, getMaxDimensions(config)) : getFullMessage(data.error);
                        } else {
                            data = {
                                errorcode: 70000,
                                error: translate('Unable to save your changes.')
                            };
                        }
                        deferred.reject(data);
                    });
                } else {
                    var data = {
                        errorcode: 70000,
                        error: getFullMessage(translate('The file you tried to upload exceeds the limit size.'), getMaxSize(config))
                    };
                    d4cNotificationService.sendNotification(data);
                    deferred.reject(data);
                }
                return deferred.promise;
            }
        };
    }]);
    app.factory('LocationHelper', function () {
        return {
            delimiter: ',',
            accuracy: 5,
            formatLatLng: function (latLng) {
                var lat = L.Util.formatNum(latLng.lat, this.accuracy);
                var lng = L.Util.formatNum(latLng.lng, this.accuracy);
                return new L.latLng(lat, lng);
            },
            getLocationParameterAsArray: function (location) {
                return location.split(this.delimiter);
            },
            getLocationParameterFromMap: function (map) {
                var center = this.formatLatLng(map.getCenter());
                return map.getZoom() + this.delimiter + center.lat + this.delimiter + center.lng;
            },
            getCenterFromLocationParameter: function (location) {
                var a = this.getLocationParameterAsArray(location);
                return new L.latLng(a[1], a[2]);
            },
            getZoomFromLocationParameter: function (location) {
                return this.getLocationParameterAsArray(location)[0];
            },
            serialize: function (center, zoom) {
                center = this.formatLatLng(center);
                return zoom + this.delimiter + center.lat + this.delimiter + center.lng;
            }
        };
    });
    app.factory('$exceptionHandler', ['$log', '$injector', function ($log, $injector) {
        var alreadySent = [];
        return function (exception, cause) {
            var $http = $injector.get('$http');
            var config = $injector.get('config');
            $log.error.apply($log, arguments);
            if (alreadySent.indexOf(exception.message) >= 0) {
                return;
            } else {
                alreadySent.push(exception.message);
            }
            if (typeof exception === "string") {
                exception = {
                    message: exception,
                    stack: ''
                };
            }
            var report = {
                message: exception.message,
                stack: exception.stack,
                userlang: navigator.language || navigator.userLanguage,
                url: window.location.href,
                request_id: config.REQUEST_ID
            };
            //$http.post('/api/errorprobe/', angular.toJson(report));
        };
    }]);
    app.service('EPSG', function () {
        var list = {
            '2154': 'Lambert 93 France',
            '3949': 'RGF93 / CC49'
        };
        return {
            nameFromEPSG: function (epsg) {
                if (angular.isDefined(list[epsg])) {
                    return list[epsg] + ' (EPSG:' + epsg + ')';
                } else {
                    return 'EPSG:' + epsg;
                }
            },
            registry: function () {
                return list;
            },
            list: function () {
                var result = [];
                angular.forEach(list, function (label, epsg) {
                    result.push({
                        label: label,
                        value: epsg
                    });
                });
                return result;
            }
        };
    });
}());;
angular.module('d4c.core').factory('d4cVueComponentFactory', function vueComponentFactory() {
    return function (directiveVars) {
        return {
            restrict: 'E',
            priority: 9999,
            terminal: true,
            compile: function (tElem) {
                tElem.attr('ng-non-bindable');
                return function (scope, iElement) {
                    var data = {};
                    var vm;
                    var _scope = scope;
                    while (_scope) {
                        angular.forEach(directiveVars || Object.keys(_scope), function (name) {
                            if (_scope.hasOwnProperty(name) && name[0] !== '$') {
                                var isObject = angular.isObject(_scope[name]);
                                data[name] = isObject ? angular.copy(_scope[name]) : _scope[name];
                                _scope.$watch(name, function (val) {
                                    if (!vm) return;
                                    vm[name] = angular.isObject(val) ? angular.copy(val) : val;
                                }, isObject);
                            }
                        });
                        _scope = _scope.$parent;
                    }
                    vm = ngVue.createVueRoot(iElement[0], data);
                };
            },
        };
    }
});;
(function () {
    "use strict";
    var mod = angular.module("d4c.core");
    mod.service('WidgetCodeBuilder', function () {
        function stringify(parameters) {
            var params = angular.copy(parameters);
            var backlist = ['tab', 'headless', 'hideTabs', 'location', 'dataChart', 'basemap'];
            for (var i = 0; i < backlist.length; i++) {
                if (params[backlist[i]]) {
                    delete params[backlist[i]];
                }
            }
            return JSON.stringify(params).replace(/'/g, "\\'").replace(/"/g, "'");
        }

        function indent(text, levels) {
            if (angular.isUndefined(levels)) {
                levels = 1;
            }
            var indentSpaces = '';
            var i = 0;
            for (i = 0; i < levels; i++) {
                indentSpaces += '    ';
            }
            return text.replace(/^(?!$)/gm, indentSpaces);
        }

        function buildContextsCode() {
            var contexts = [];
            var contextsName = [];
            return {
                addContext: function (context, contextName) {
                    if (angular.isUndefined(contextName)) {
                        contextName = context.dataset.datasetid.replace(/[_@-]/g, '').replace(/^[0-9]+/, '');
                    }
                    if (contextName === '') {
                        contextName = 'myctx';
                    }
                    for (var i = 0; i < contexts.length; i++) {
                        if (contexts[i].dataset.datasetid === context.dataset.datasetid && contexts[i].domain === context.domain) {
                            var equals = true;
                            angular.forEach(contexts[i].parameters, function (value, key) {
                                if (contexts[i].parameters[key] !== context.parameters[key]) {
                                    equals = false;
                                }
                            });
                            angular.forEach(context.parameters, function (value, key) {
                                if (contexts[i].parameters[key] !== context.parameters[key]) {
                                    equals = false;
                                }
                            });
                            if (equals) {
                                return contextsName[i];
                            }
                        }
                    }
                    var j = 0;
                    var originalContextName = contextName;
                    while (contextsName.indexOf(contextName) >= 0) {
                        contextName = originalContextName + j;
                        j++;
                    }
                    contexts.push(context);
                    contextsName.push(contextName);
                    return contextName;
                },
                wrapInContextsCode: function (widgetCode) {
					
                    var code = "<d4c-dataset-context ",
                        context, contextName;
                    code += 'context="' + contextsName.join(',') + '"';
                    for (var i = 0; i < contexts.length; i++) {
                        contextName = contextsName[i];
                        context = contexts[i];
                        code += ' ' + contextName + '-dataset="' + context.dataset.datasetid + '"';
                        if (context.domain) {
                            code += ' ' + contextName + '-domain="' + context.domain + '"';
                        }
                        if (context.parameters && !isObjectEmpty(context.parameters)) {
                            code += ' ' + contextName + '-parameters="' + stringify(context.parameters) + '"';
                        }
                    }
                    code += ">\n";
                    return code + indent(widgetCode, 1) + "\n</d4c-dataset-context>";
                }
            };
        }
        return {
            buildMediaWidgetCode: function (context, search_parameters) {
                var contextsCodeBuilder = buildContextsCode(),
                    widgetCode = '<d4c-media-gallery';
                widgetCode += ' context="' + contextsCodeBuilder.addContext(context) + '"';
                widgetCode += ' d4c-widget-tooltip';
                widgetCode += ' d4c-auto-resize';
                widgetCode += ' display-mode="compact"';
                widgetCode += '></d4c-media-gallery>\n';
                return contextsCodeBuilder.wrapInContextsCode(widgetCode);
            },
            buildMapWidgetCode: function (context, search_parameters) {
                var contextsCodeBuilder = buildContextsCode(),
                    widgetCode = '<d4c-map';
                widgetCode += ' context="' + contextsCodeBuilder.addContext(context) + '"';
                widgetCode += ' scroll-wheel-zoom="false"';
                if (search_parameters.location) {
                    widgetCode += ' location="' + search_parameters.location + '"';
                }
                if (search_parameters.basemap) {
                    widgetCode += ' basemap="' + search_parameters.basemap + '"';
                }
                widgetCode += '></d4c-map>\n';
                return contextsCodeBuilder.wrapInContextsCode(widgetCode);
            },
            buildTableWidgetCode: function (context, search_parameters) {
                var contextsCodeBuilder = buildContextsCode(),
                    widgetCode = '<d4c-table';
                widgetCode += ' context="' + contextsCodeBuilder.addContext(context) + '"';
                if (search_parameters.sort) {
                    widgetCode += ' sort="' + search_parameters.sort + '"';
                }
                widgetCode += '></d4c-table>\n';
                return contextsCodeBuilder.wrapInContextsCode(widgetCode);
            },
            buildChartWidgetCode: function (chartConfig) {
                var contextsCodeBuilder = buildContextsCode(),
                    widgetCode = "";
                if (chartConfig) {
                    widgetCode = '<d4c-chart';
                    if (chartConfig.timescale) {
                        widgetCode += ' timescale="' + chartConfig.timescale + '"';
                    }
                    if (chartConfig.singleAxis) {
                        widgetCode += ' single-y-axis="' + chartConfig.singleAxis + '"';
                    }
                    if (chartConfig.singleAxisLabel) {
                        widgetCode += ' single-y-axis-label="' + chartConfig.singleAxisLabel + '"';
                    }
                    if (chartConfig.singleAxisScale === "logarithmic") {
                        widgetCode += ' logarithmic="true"';
                    }
                    if (typeof chartConfig.yRangeMin !== "undefined") {
                        widgetCode += ' min="' + chartConfig.yRangeMin + '"';
                    }
                    if (typeof chartConfig.yRangeMax !== "undefined") {
                        widgetCode += ' max="' + chartConfig.yRangeMax + '"';
                    }
                    if (typeof chartConfig.yStep !== "undefined") {
                        widgetCode += ' step="' + chartConfig.yStep + '"';
                    }
                    if (typeof chartConfig.scientificDisplay !== "undefined") {
                        widgetCode += ' scientific-display="' + chartConfig.scientificDisplay + '"';
                    }
                    if (chartConfig.displayLegend === false) {
                        widgetCode += ' display-legend="false"';
                    }
                    if (typeof chartConfig.labelsXLength !== "undefined") {
                        widgetCode += ' labels-x-length="' + chartConfig.labelsXLength + '"';
                    }
                    if (typeof chartConfig.alignMonth !== "undefined") {
                        widgetCode += ' align-month="' + chartConfig.alignMonth + '"';
                    }
                    widgetCode += '>\n';
                    if (chartConfig.queries) {
                        for (var i = 0; i < chartConfig.queries.length; i++) {
                            var query = chartConfig.queries[i];
                            var context = {
                                parameters: query.config.options,
                                dataset: {
                                    datasetid: query.config.dataset
                                },
                                domain: ''
                            };
                            widgetCode += indent('<d4c-chart-query');
                            widgetCode += ' context="' + contextsCodeBuilder.addContext(context) + '"';
                            if (query.xAxis) {
                                widgetCode += ' field-x="' + query.xAxis + '"';
                            }
                            if (query.maxpoints) {
                                widgetCode += ' maxpoints="' + query.maxpoints + '"';
                            } else {
                                widgetCode += ' maxpoints="0"';
                            }
                            if